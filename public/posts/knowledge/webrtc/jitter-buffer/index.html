<!DOCTYPE html>
<html lang="zh-cn">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width">
    <script type="application/javascript" src='https://ayamir.github.io/js/theme-mode.js'></script>
    <link rel="stylesheet" href='https://ayamir.github.io/css/frameworks.min.css' />
    <link rel="stylesheet" href='https://ayamir.github.io/css/github.min.css' />
    <link rel="stylesheet" href='https://ayamir.github.io/css/github-style.css' />
    <link rel="stylesheet" href='https://ayamir.github.io/css/light.css' />
    <link rel="stylesheet" href='https://ayamir.github.io/css/dark.css' />
    <link rel="stylesheet" href='https://ayamir.github.io/css/syntax.css' />
    <title>Jitter Buffer学习理解（上） - Ayamir&#39;s blog</title>
    
    <link rel="icon" type="image/x-icon" href='/images/favicon.png'>
    
    <meta name="theme-color" content="#1e2327">

    
    <meta name="description"
  content="这篇博客主要分析理解 WebRTC 中的 Jitter Buffer 的工作职责以及 Buffer 相关的代码实现。" />
<meta name="keywords"
  content='webrtc' />
<meta name="robots" content="noodp" />
<link rel="canonical" href="https://ayamir.github.io/posts/knowledge/webrtc/jitter-buffer/" />


<meta name="twitter:card" content="summary" />
<meta name="twitter:title" content="Jitter Buffer学习理解（上） - Ayamir&#39;s blog" />
<meta name="twitter:description"
  content="这篇博客主要分析理解 WebRTC 中的 Jitter Buffer 的工作职责以及 Buffer 相关的代码实现。" />
<meta name="twitter:site" content="https://ayamir.github.io/" />
<meta name="twitter:creator" content="" />
<meta name="twitter:image"
  content="https://ayamir.github.io/">


<meta property="og:type" content="article" />
<meta property="og:title" content="Jitter Buffer学习理解（上） - Ayamir&#39;s blog">
<meta property="og:description"
  content="这篇博客主要分析理解 WebRTC 中的 Jitter Buffer 的工作职责以及 Buffer 相关的代码实现。" />
<meta property="og:url" content="https://ayamir.github.io/posts/knowledge/webrtc/jitter-buffer/" />
<meta property="og:site_name" content="Jitter Buffer学习理解（上）" />
<meta property="og:image"
  content="https://ayamir.github.io/">
<meta property="og:image:width" content="2048">
<meta property="og:image:height" content="1024">

<meta property="article:published_time" content="2024-04-18 17:33:24 &#43;0800 CST" />











<script>
var doNotTrack = false;
if (!doNotTrack) {
	(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
	(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
	m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
	})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
	ga('create', 'UA-123456-789', 'auto');
	
	ga('send', 'pageview');
}
</script>


</head>

<body>
  <div style="position: relative">
  <header class="Header js-details-container Details px-3 px-md-4 px-lg-5 flex-wrap flex-md-nowrap open Details--on">
    <div class="Header-item mobile-none" style="margin-top: -4px; margin-bottom: -4px;">
      <a class="Header-link" href="https://ayamir.github.io/">
        <img class="octicon" height="32" width="32" src="/images/GitHub-Mark-Light-32px.png">
      </a>
    </div>
    <div class="Header-item d-md-none">
      <button class="Header-link btn-link js-details-target" type="button"
        onclick="document.querySelector('#header-search').style.display = document.querySelector('#header-search').style.display == 'none'? 'block': 'none'">
        <img height="24" class="octicon octicon-three-bars" width="24" src="/images/GitHub-Mark-Light-32px.png">
      </button>
    </div>
    <div style="display: none;" id="header-search"
      class="Header-item Header-item--full flex-column flex-md-row width-full flex-order-2 flex-md-order-none mr-0 mr-md-3 mt-3 mt-md-0 Details-content--hidden-not-important d-md-flex">
      <div
        class="Header-search header-search flex-auto js-site-search position-relative flex-self-stretch flex-md-self-auto mb-3 mb-md-0 mr-0 mr-md-3 scoped-search site-scoped-search js-jump-to">
        <div class="position-relative">
          <form target="_blank" action="https://www.google.com/search" accept-charset="UTF-8" method="get"
            autocomplete="off">
            <label
              class="Header-search-label form-control input-sm header-search-wrapper p-0 js-chromeless-input-container header-search-wrapper-jump-to position-relative d-flex flex-justify-between flex-items-center">
              <input type="text"
                class="Header-search-input form-control input-sm header-search-input jump-to-field js-jump-to-field js-site-search-focus js-site-search-field is-clearable"
                name="q" value="" placeholder="Search" autocomplete="off">
              <input type="hidden" name="q" value="site:https://ayamir.github.io/">
            </label>
          </form>
        </div>
      </div>
    </div>

    <div class="Header-item Header-item--full flex-justify-center d-md-none position-relative">
      <a class="Header-link " href="https://ayamir.github.io/">
        <img class="octicon octicon-mark-github v-align-middle" height="32" width="32" src="/images/GitHub-Mark-Light-32px.png">
      </a>
    </div>
    <div class="Header-item" style="margin-right: 0;">
      <a href="javascript:void(0)" class="Header-link no-select" onclick="switchTheme()">
        <svg style="fill: var(--color-profile-color-modes-toggle-moon);" class="no-select" viewBox="0 0 16 16"
          version="1.1" width="16" height="16">
          <path fill-rule="evenodd" clip-rule="evenodd"
            d="M4.52208 7.71754C7.5782 7.71754 10.0557 5.24006 10.0557 2.18394C10.0557 1.93498 10.0392 1.68986 10.0074 1.44961C9.95801 1.07727 10.3495 0.771159 10.6474 0.99992C12.1153 2.12716 13.0615 3.89999 13.0615 5.89383C13.0615 9.29958 10.3006 12.0605 6.89485 12.0605C3.95334 12.0605 1.49286 10.001 0.876728 7.24527C0.794841 6.87902 1.23668 6.65289 1.55321 6.85451C2.41106 7.40095 3.4296 7.71754 4.52208 7.71754Z">
          </path>
        </svg>
      </a>
    </div>
  </header>
</div>

  
<div>
  <main>
    <div class="gisthead pagehead bg-gray-light pb-0 pt-3 mb-4">
      <div class="px-0">
        <div class="mb-3 d-flex px-3 px-md-3 px-lg-5">
          <div class="flex-auto min-width-0 width-fit mr-3">
            <div class="d-flex">
              <div class="d-none d-md-block">
                <a class="avatar mr-2 flex-shrink-0" href="https://ayamir.github.io/">
                  <img class=" avatar-user"
                    src="/images/avatar.png"
                    width="32" height="32"></a>
              </div>
              <div class="d-flex flex-column">
                <h1 class="break-word f3 text-normal mb-md-0 mb-1">
                  <span class="author">
                    <a href="https://ayamir.github.io/"></a>
                  </span>
                  <span class="path-divider">/</span>
                  <strong class="css-truncate css-truncate-target mr-1" style="max-width: 410px">
                    <a href="https://ayamir.github.io/posts/knowledge/webrtc/jitter-buffer/">Jitter Buffer学习理解（上）</a>
                  </strong>
                </h1>
                <div class="note m-0">
                  Created <relative-time datetime="Thu, 18 Apr 2024 17:33:24 &#43;0800"
                    class="no-wrap">
                    Thu, 18 Apr 2024 17:33:24 &#43;0800</relative-time>

                  
                  <span class="file-info-divider"></span>
                  Modified <relative-time datetime="Fri, 26 Apr 2024 09:02:15 &#43;0800"
                    class="no-wrap">
                    Fri, 26 Apr 2024 09:02:15 &#43;0800</relative-time>
                  
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>

    <div class="container-lg px-3 new-discussion-timeline">
      <div class="repository-content gist-content">
        <div>
          <div class="js-gist-file-update-container js-task-list-container file-box">
            <div id="file-pytest" class="file my-2">
              <div id="post-header" class="file-header d-flex flex-md-items-center flex-items-start sticky-header" style="z-index: 2">
                <div class="file-info d-flex flex-md-items-center flex-items-start flex-order-1 flex-auto">
                  <div class="text-mono f6 flex-auto pr-3 flex-order-2 flex-md-order-1 mt-2 mt-md-0">
                    
                    <summary id="toc-toggle" onclick="clickToc()" class="btn btn-octicon m-0 mr-2 p-2">
                      <svg aria-hidden="true" viewBox="0 0 16 16" height="16" width="16" class="octicon octicon-list-unordered">
                        <path fill-rule="evenodd" d="M2 4a1 1 0 100-2 1 1 0 000 2zm3.75-1.5a.75.75 0 000 1.5h8.5a.75.75 0 000-1.5h-8.5zm0 5a.75.75 0 000 1.5h8.5a.75.75 0 000-1.5h-8.5zm0 5a.75.75 0 000 1.5h8.5a.75.75 0 000-1.5h-8.5zM3 8a1 1 0 11-2 0 1 1 0 012 0zm-1 6a1 1 0 100-2 1 1 0 000 2z"></path>
                      </svg>
                    </summary>
                    <details-menu class="SelectMenu" id="toc-details" style="display: none;">
                      <div class="SelectMenu-modal rounded-3 mt-1" style="max-height: 340px;">
                        <div class="SelectMenu-list SelectMenu-list--borderless p-2" style="overscroll-behavior: contain;" id="toc-list">
                        </div>
                      </div>
                    </details-menu>
                      7416 Words
                    

                  </div>
                  <div class="file-actions flex-order-2 pt-0">
                    
                    
                    <a class="muted-link mr-3" href="/tags/webrtc">
                      <svg class="octicon octicon-tag" viewBox="0 0 16 16" version="1.1" width="16" height="16">
                        <path fill-rule="evenodd"
                          d="M2.5 7.775V2.75a.25.25 0 01.25-.25h5.025a.25.25 0 01.177.073l6.25 6.25a.25.25 0 010 .354l-5.025 5.025a.25.25 0 01-.354 0l-6.25-6.25a.25.25 0 01-.073-.177zm-1.5 0V2.75C1 1.784 1.784 1 2.75 1h5.025c.464 0 .91.184 1.238.513l6.25 6.25a1.75 1.75 0 010 2.474l-5.026 5.026a1.75 1.75 0 01-2.474 0l-6.25-6.25A1.75 1.75 0 011 7.775zM6 5a1 1 0 100 2 1 1 0 000-2z">
                        </path>
                      </svg>
                      WebRTC
                    </a>
                    
                    
                  </div>
                </div>
              </div>


              <div class="Box-body px-5 pb-5" style="z-index: 1">
                <article class="markdown-body entry-content container-lg"><h2 id="jitter-buffer-是什么">Jitter Buffer 是什么</h2>
<p>在了解 Jitter Buffer 之前，我们应该先来看一下整个 webrtc 会话中数据传输的完整流程。</p>
<p><img src="https://raw.githubusercontent.com/ayamir/blog-imgs/main/image-20240418175944047.png" alt="image-20240418175944047"></p>
<p>与传输相关的部分主要出现在 pacer 和 Jitter Buffer 这两个部分，从图中可以清晰的看到这两者处于编解码和网络传输之间，考虑到编解码可能会引入突变的帧大小（比如 I 帧），而在网络传输的过程又受到网络传输速率和排队延迟的影响，所以它们的作用其实就比较显而易见了。Pacer 在发送端负责平滑编码后的码流打包成 rtp 包之后，发送到网络上的速率；Jitter Buffer 在接收端负责平滑接收到的 rtp 包到组成解码所需的码流的过程。</p>
<p>当然，这个传输的过程中离开不了拥塞控制算法如 gcc 和各种抗丢包的技术如 nack，fec 等来保障实时通信质量。在这里我们主要关注传输的流程，相关算法和机制之后再研究。</p>
<p>Jitter Buffer 可以理解为有两部分的功能，一部分是 Buffer 的功能，也就是作为 rtp 包的缓冲区，并且将 rtp 包恢复成表示可解码帧的码流；另一部分是 Jitter 的功能，也就是通过引入延迟来平滑因帧大小和网络状况而造成的接收帧不均匀的情况。</p>
<h2 id="buffer-的工作流程">buffer 的工作流程</h2>
<p>正如前面所说，网络传输的是 rtp 包，而解码器的输入是可以解码的码流，所以需要一个将 rtp 包转换成可以解码的帧的过程。因为一个帧由多个 rtp 包组成，所以肯定需要缓冲区来存放前面收到但是还不足以组成一个帧的 rtp 包，这个缓冲区在 webrtc 中其实就是<code>PacketBuffer</code>。此外，考虑到编解码原理，接收到的 P 帧还需要等它所依赖的 I 帧/P 帧被解码，它才能被解码，所以在<code>PacketBuffer</code>之外还需要一个<code>FrameBuffer</code>来缓存可以解码的一个 GOP 中的各个帧。而负责寻找当前帧所依赖帧的是<code>RtpFrameReferenceFinder</code>，因为这个寻找依赖帧的过程实际上是递归依赖的，直到找到一个 GOP 的 IDR 帧才算结束，这样就能得到按照解码依赖顺序排列的一个 GOP。而最后，因为不同 GOP 的解码是独立的，所以 GOP 之间实际上就直接按照时间顺序排列就完成了 GOP 的排序。</p>
<p>总体上来看，buffer 负责的工作就是 3 个：rtp 包的排序并组成帧、帧的排序并组成 GOP、GOP 的排序并组成视频。</p>
<h2 id="代码实现">代码实现</h2>
<p>结合代码逻辑来看一下实际的工作流程，最核心的类是<code>RtpVideoStreamReceiver2</code>，这个类负责完成上面所说的工作内容的实现与逻辑的拆分，不过除了上面这些逻辑之外，这个类还需要向发送端发送 rtcp 反馈包的工作，比如 nack, pli, fir。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">RtpVideoStreamReceiver2</span> <span class="o">:</span> <span class="k">public</span> <span class="n">LossNotificationSender</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                                <span class="k">public</span> <span class="n">RecoveredPacketReceiver</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                                <span class="k">public</span> <span class="n">RtpPacketSinkInterface</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                                <span class="k">public</span> <span class="n">KeyFrameRequestSender</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                                <span class="k">public</span> <span class="n">NackSender</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                                <span class="k">public</span> <span class="n">OnDecryptedFrameCallback</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                                <span class="k">public</span> <span class="n">OnDecryptionStatusChangeCallback</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                                <span class="k">public</span> <span class="n">RtpVideoFrameReceiver</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"> <span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// A complete frame is a frame which has received all its packets and all its
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// references are known.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">class</span> <span class="nc">OnCompleteFrameCallback</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">   <span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="k">virtual</span> <span class="o">~</span><span class="n">OnCompleteFrameCallback</span><span class="p">()</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl">    <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">OnCompleteFrame</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">EncodedFrame</span><span class="o">&gt;</span> <span class="n">frame</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">RtpVideoStreamReceiver2</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">      <span class="n">TaskQueueBase</span><span class="o">*</span> <span class="n">current_queue</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">      <span class="n">Clock</span><span class="o">*</span> <span class="n">clock</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">      <span class="n">Transport</span><span class="o">*</span> <span class="n">transport</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">      <span class="n">RtcpRttStats</span><span class="o">*</span> <span class="n">rtt_stats</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">      <span class="c1">// The packet router is optional; if provided, the RtpRtcp module for this
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="c1">// stream is registered as a candidate for sending REMB and transport
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="c1">// feedback.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="n">PacketRouter</span><span class="o">*</span> <span class="n">packet_router</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">      <span class="k">const</span> <span class="n">VideoReceiveStreamInterface</span><span class="o">::</span><span class="n">Config</span><span class="o">*</span> <span class="n">config</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">      <span class="n">ReceiveStatistics</span><span class="o">*</span> <span class="n">rtp_receive_statistics</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">      <span class="n">RtcpPacketTypeCounterObserver</span><span class="o">*</span> <span class="n">rtcp_packet_type_counter_observer</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">      <span class="n">RtcpCnameCallback</span><span class="o">*</span> <span class="n">rtcp_cname_callback</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">      <span class="n">NackPeriodicProcessor</span><span class="o">*</span> <span class="n">nack_periodic_processor</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">      <span class="c1">// The KeyFrameRequestSender is optional; if not provided, key frame
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="c1">// requests are sent via the internal RtpRtcp module.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="n">OnCompleteFrameCallback</span><span class="o">*</span> <span class="n">complete_frame_callback</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">      <span class="n">rtc</span><span class="o">::</span><span class="n">scoped_refptr</span><span class="o">&lt;</span><span class="n">FrameDecryptorInterface</span><span class="o">&gt;</span> <span class="n">frame_decryptor</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">      <span class="n">rtc</span><span class="o">::</span><span class="n">scoped_refptr</span><span class="o">&lt;</span><span class="n">FrameTransformerInterface</span><span class="o">&gt;</span> <span class="n">frame_transformer</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">      <span class="k">const</span> <span class="n">FieldTrialsView</span><span class="o">&amp;</span> <span class="n">field_trials</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">      <span class="n">RtcEventLog</span><span class="o">*</span> <span class="n">event_log</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="o">~</span><span class="n">RtpVideoStreamReceiver2</span><span class="p">()</span> <span class="k">override</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="kt">void</span> <span class="nf">AddReceiveCodec</span><span class="p">(</span><span class="kt">uint8_t</span> <span class="n">payload_type</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                       <span class="n">VideoCodecType</span> <span class="n">video_codec</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                       <span class="k">const</span> <span class="n">webrtc</span><span class="o">::</span><span class="n">CodecParameterMap</span><span class="o">&amp;</span> <span class="n">codec_params</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                       <span class="kt">bool</span> <span class="n">raw_payload</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// Clears state for all receive codecs added via `AddReceiveCodec`.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">void</span> <span class="nf">RemoveReceiveCodecs</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="kt">void</span> <span class="nf">StartReceive</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="kt">void</span> <span class="nf">StopReceive</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// Produces the transport-related timestamps; current_delay_ms is left unset.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">absl</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="n">Syncable</span><span class="o">::</span><span class="n">Info</span><span class="o">&gt;</span> <span class="n">GetSyncInfo</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="kt">bool</span> <span class="nf">DeliverRtcp</span><span class="p">(</span><span class="k">const</span> <span class="kt">uint8_t</span><span class="o">*</span> <span class="n">rtcp_packet</span><span class="p">,</span> <span class="n">size_t</span> <span class="n">rtcp_packet_length</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="kt">void</span> <span class="nf">FrameContinuous</span><span class="p">(</span><span class="kt">int64_t</span> <span class="n">seq_num</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="kt">void</span> <span class="nf">FrameDecoded</span><span class="p">(</span><span class="kt">int64_t</span> <span class="n">seq_num</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="kt">void</span> <span class="nf">SignalNetworkState</span><span class="p">(</span><span class="n">NetworkState</span> <span class="n">state</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// Returns number of different frames seen.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">int</span> <span class="nf">GetUniqueFramesSeen</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">RTC_DCHECK_RUN_ON</span><span class="p">(</span><span class="o">&amp;</span><span class="n">packet_sequence_checker_</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">frame_counter_</span><span class="p">.</span><span class="n">GetUniqueSeen</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// Implements RtpPacketSinkInterface.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">void</span> <span class="nf">OnRtpPacket</span><span class="p">(</span><span class="k">const</span> <span class="n">RtpPacketReceived</span><span class="o">&amp;</span> <span class="n">packet</span><span class="p">)</span> <span class="k">override</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// Public only for tests.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// Returns true if the packet should be stashed and retried at a later stage.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">bool</span> <span class="nf">OnReceivedPayloadData</span><span class="p">(</span><span class="n">rtc</span><span class="o">::</span><span class="n">CopyOnWriteBuffer</span> <span class="n">codec_payload</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                             <span class="k">const</span> <span class="n">RtpPacketReceived</span><span class="o">&amp;</span> <span class="n">rtp_packet</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                             <span class="k">const</span> <span class="n">RTPVideoHeader</span><span class="o">&amp;</span> <span class="n">video</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                             <span class="kt">int</span> <span class="n">times_nacked</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// Implements RecoveredPacketReceiver.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">void</span> <span class="nf">OnRecoveredPacket</span><span class="p">(</span><span class="k">const</span> <span class="n">RtpPacketReceived</span><span class="o">&amp;</span> <span class="n">packet</span><span class="p">)</span> <span class="k">override</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// Send an RTCP keyframe request.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">void</span> <span class="nf">RequestKeyFrame</span><span class="p">()</span> <span class="k">override</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// Implements NackSender.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">void</span> <span class="nf">SendNack</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">uint16_t</span><span class="o">&gt;&amp;</span> <span class="n">sequence_numbers</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                <span class="kt">bool</span> <span class="n">buffering_allowed</span><span class="p">)</span> <span class="k">override</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// Implements LossNotificationSender.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">void</span> <span class="nf">SendLossNotification</span><span class="p">(</span><span class="kt">uint16_t</span> <span class="n">last_decoded_seq_num</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                            <span class="kt">uint16_t</span> <span class="n">last_received_seq_num</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                            <span class="kt">bool</span> <span class="n">decodability_flag</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                            <span class="kt">bool</span> <span class="n">buffering_allowed</span><span class="p">)</span> <span class="k">override</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// Returns true if a decryptor is attached and frames can be decrypted.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// Updated by OnDecryptionStatusChangeCallback. Note this refers to Frame
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// Decryption not SRTP.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">bool</span> <span class="nf">IsDecryptable</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// Implements OnDecryptedFrameCallback.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">void</span> <span class="nf">OnDecryptedFrame</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">RtpFrameObject</span><span class="o">&gt;</span> <span class="n">frame</span><span class="p">)</span> <span class="k">override</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// Implements OnDecryptionStatusChangeCallback.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">void</span> <span class="nf">OnDecryptionStatusChange</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">      <span class="n">FrameDecryptorInterface</span><span class="o">::</span><span class="n">Status</span> <span class="n">status</span><span class="p">)</span> <span class="k">override</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// Optionally set a frame decryptor after a stream has started. This will not
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// reset the decoder state.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">void</span> <span class="nf">SetFrameDecryptor</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">      <span class="n">rtc</span><span class="o">::</span><span class="n">scoped_refptr</span><span class="o">&lt;</span><span class="n">FrameDecryptorInterface</span><span class="o">&gt;</span> <span class="n">frame_decryptor</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// Sets a frame transformer after a stream has started, if no transformer
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// has previously been set. Does not reset the decoder state.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">void</span> <span class="nf">SetDepacketizerToDecoderFrameTransformer</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">      <span class="n">rtc</span><span class="o">::</span><span class="n">scoped_refptr</span><span class="o">&lt;</span><span class="n">FrameTransformerInterface</span><span class="o">&gt;</span> <span class="n">frame_transformer</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// Called by VideoReceiveStreamInterface when stats are updated.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">void</span> <span class="nf">UpdateRtt</span><span class="p">(</span><span class="kt">int64_t</span> <span class="n">max_rtt_ms</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// Called when the local_ssrc is changed to match with a sender.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">void</span> <span class="nf">OnLocalSsrcChange</span><span class="p">(</span><span class="kt">uint32_t</span> <span class="n">local_ssrc</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// Forwards the call to set rtcp_sender_ to the RTCP mode of the rtcp sender.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">void</span> <span class="nf">SetRtcpMode</span><span class="p">(</span><span class="n">RtcpMode</span> <span class="n">mode</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="kt">void</span> <span class="nf">SetReferenceTimeReport</span><span class="p">(</span><span class="kt">bool</span> <span class="n">enabled</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// Sets or clears the callback sink that gets called for RTP packets. Used for
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// packet handlers such as FlexFec. Must be called on the packet delivery
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// thread (same context as `OnRtpPacket` is called on).
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// TODO(bugs.webrtc.org/11993): Packet delivery thread today means `worker
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// thread` but will be `network thread`.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">void</span> <span class="nf">SetPacketSink</span><span class="p">(</span><span class="n">RtpPacketSinkInterface</span><span class="o">*</span> <span class="n">packet_sink</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// Turns on/off loss notifications. Must be called on the packet delivery
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// thread.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">void</span> <span class="nf">SetLossNotificationEnabled</span><span class="p">(</span><span class="kt">bool</span> <span class="n">enabled</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="kt">void</span> <span class="nf">SetNackHistory</span><span class="p">(</span><span class="n">TimeDelta</span> <span class="n">history</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="kt">int</span> <span class="nf">ulpfec_payload_type</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="kt">int</span> <span class="nf">red_payload_type</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="kt">void</span> <span class="nf">SetProtectionPayloadTypes</span><span class="p">(</span><span class="kt">int</span> <span class="n">red_payload_type</span><span class="p">,</span> <span class="kt">int</span> <span class="n">ulpfec_payload_type</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">absl</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="kt">int64_t</span><span class="o">&gt;</span> <span class="n">LastReceivedPacketMs</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">absl</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="kt">uint32_t</span><span class="o">&gt;</span> <span class="n">LastReceivedFrameRtpTimestamp</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">absl</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="kt">int64_t</span><span class="o">&gt;</span> <span class="n">LastReceivedKeyframePacketMs</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">absl</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="n">RtpRtcpInterface</span><span class="o">::</span><span class="n">SenderReportStats</span><span class="o">&gt;</span> <span class="n">GetSenderReportStats</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">      <span class="k">const</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> <span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// Implements RtpVideoFrameReceiver.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">void</span> <span class="n">ManageFrame</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">RtpFrameObject</span><span class="o">&gt;</span> <span class="n">frame</span><span class="p">)</span> <span class="k">override</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="kt">void</span> <span class="nf">OnCompleteFrames</span><span class="p">(</span><span class="n">RtpFrameReferenceFinder</span><span class="o">::</span><span class="n">ReturnVector</span> <span class="n">frame</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">      <span class="n">RTC_RUN_ON</span><span class="p">(</span><span class="n">packet_sequence_checker_</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// Used for buffering RTCP feedback messages and sending them all together.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// Note:
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// 1. Key frame requests and NACKs are mutually exclusive, with the
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">//    former taking precedence over the latter.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// 2. Loss notifications are orthogonal to either. (That is, may be sent
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">//    alongside either.)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">class</span> <span class="nc">RtcpFeedbackBuffer</span> <span class="o">:</span> <span class="k">public</span> <span class="n">KeyFrameRequestSender</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                             <span class="k">public</span> <span class="n">NackSender</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                             <span class="k">public</span> <span class="n">LossNotificationSender</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">   <span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">RtcpFeedbackBuffer</span><span class="p">(</span><span class="n">KeyFrameRequestSender</span><span class="o">*</span> <span class="n">key_frame_request_sender</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                       <span class="n">NackSender</span><span class="o">*</span> <span class="n">nack_sender</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                       <span class="n">LossNotificationSender</span><span class="o">*</span> <span class="n">loss_notification_sender</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="o">~</span><span class="n">RtcpFeedbackBuffer</span><span class="p">()</span> <span class="k">override</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// KeyFrameRequestSender implementation.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">void</span> <span class="nf">RequestKeyFrame</span><span class="p">()</span> <span class="k">override</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// NackSender implementation.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">void</span> <span class="nf">SendNack</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">uint16_t</span><span class="o">&gt;&amp;</span> <span class="n">sequence_numbers</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                  <span class="kt">bool</span> <span class="n">buffering_allowed</span><span class="p">)</span> <span class="k">override</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// LossNotificationSender implementation.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">void</span> <span class="nf">SendLossNotification</span><span class="p">(</span><span class="kt">uint16_t</span> <span class="n">last_decoded_seq_num</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                              <span class="kt">uint16_t</span> <span class="n">last_received_seq_num</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                              <span class="kt">bool</span> <span class="n">decodability_flag</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                              <span class="kt">bool</span> <span class="n">buffering_allowed</span><span class="p">)</span> <span class="k">override</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// Send all RTCP feedback messages buffered thus far.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">void</span> <span class="nf">SendBufferedRtcpFeedback</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="nf">ClearLossNotificationState</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">   <span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// LNTF-related state.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">struct</span> <span class="nc">LossNotificationState</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">LossNotificationState</span><span class="p">(</span><span class="kt">uint16_t</span> <span class="n">last_decoded_seq_num</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                            <span class="kt">uint16_t</span> <span class="n">last_received_seq_num</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                            <span class="kt">bool</span> <span class="n">decodability_flag</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">          <span class="o">:</span> <span class="n">last_decoded_seq_num</span><span class="p">(</span><span class="n">last_decoded_seq_num</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">            <span class="n">last_received_seq_num</span><span class="p">(</span><span class="n">last_received_seq_num</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">            <span class="n">decodability_flag</span><span class="p">(</span><span class="n">decodability_flag</span><span class="p">)</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      <span class="kt">uint16_t</span> <span class="n">last_decoded_seq_num</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="kt">uint16_t</span> <span class="n">last_received_seq_num</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="kt">bool</span> <span class="n">decodability_flag</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">RTC_NO_UNIQUE_ADDRESS</span> <span class="n">SequenceChecker</span> <span class="n">packet_sequence_checker_</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">KeyFrameRequestSender</span><span class="o">*</span> <span class="k">const</span> <span class="n">key_frame_request_sender_</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">NackSender</span><span class="o">*</span> <span class="k">const</span> <span class="n">nack_sender_</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">LossNotificationSender</span><span class="o">*</span> <span class="k">const</span> <span class="n">loss_notification_sender_</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// Key-frame-request-related state.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">bool</span> <span class="n">request_key_frame_</span> <span class="nf">RTC_GUARDED_BY</span><span class="p">(</span><span class="n">packet_sequence_checker_</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// NACK-related state.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">uint16_t</span><span class="o">&gt;</span> <span class="n">nack_sequence_numbers_</span>
</span></span><span class="line"><span class="cl">        <span class="n">RTC_GUARDED_BY</span><span class="p">(</span><span class="n">packet_sequence_checker_</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">absl</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="n">LossNotificationState</span><span class="o">&gt;</span> <span class="n">lntf_state_</span>
</span></span><span class="line"><span class="cl">        <span class="n">RTC_GUARDED_BY</span><span class="p">(</span><span class="n">packet_sequence_checker_</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">};</span>
</span></span><span class="line"><span class="cl">  <span class="k">enum</span> <span class="nc">ParseGenericDependenciesResult</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">kStashPacket</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="n">kDropPacket</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="n">kHasGenericDescriptor</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="n">kNoGenericDescriptor</span>
</span></span><span class="line"><span class="cl">  <span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// Entry point doing non-stats work for a received packet. Called
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// for the same packet both before and after RED decapsulation.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">void</span> <span class="nf">ReceivePacket</span><span class="p">(</span><span class="k">const</span> <span class="n">RtpPacketReceived</span><span class="o">&amp;</span> <span class="n">packet</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">      <span class="n">RTC_RUN_ON</span><span class="p">(</span><span class="n">packet_sequence_checker_</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// Parses and handles RED headers.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// This function assumes that it&#39;s being called from only one thread.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">void</span> <span class="nf">ParseAndHandleEncapsulatingHeader</span><span class="p">(</span><span class="k">const</span> <span class="n">RtpPacketReceived</span><span class="o">&amp;</span> <span class="n">packet</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">      <span class="n">RTC_RUN_ON</span><span class="p">(</span><span class="n">packet_sequence_checker_</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="kt">void</span> <span class="nf">NotifyReceiverOfEmptyPacket</span><span class="p">(</span><span class="kt">uint16_t</span> <span class="n">seq_num</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">      <span class="n">RTC_RUN_ON</span><span class="p">(</span><span class="n">packet_sequence_checker_</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="kt">bool</span> <span class="nf">IsRedEnabled</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="kt">void</span> <span class="nf">InsertSpsPpsIntoTracker</span><span class="p">(</span><span class="kt">uint8_t</span> <span class="n">payload_type</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">      <span class="n">RTC_RUN_ON</span><span class="p">(</span><span class="n">packet_sequence_checker_</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="kt">void</span> <span class="nf">OnInsertedPacket</span><span class="p">(</span><span class="n">video_coding</span><span class="o">::</span><span class="n">PacketBuffer</span><span class="o">::</span><span class="n">InsertResult</span> <span class="n">result</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">      <span class="n">RTC_RUN_ON</span><span class="p">(</span><span class="n">packet_sequence_checker_</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">ParseGenericDependenciesResult</span> <span class="nf">ParseGenericDependenciesExtension</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">      <span class="k">const</span> <span class="n">RtpPacketReceived</span><span class="o">&amp;</span> <span class="n">rtp_packet</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">      <span class="n">RTPVideoHeader</span><span class="o">*</span> <span class="n">video_header</span><span class="p">)</span> <span class="n">RTC_RUN_ON</span><span class="p">(</span><span class="n">packet_sequence_checker_</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="kt">void</span> <span class="nf">OnAssembledFrame</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">RtpFrameObject</span><span class="o">&gt;</span> <span class="n">frame</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">      <span class="n">RTC_RUN_ON</span><span class="p">(</span><span class="n">packet_sequence_checker_</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="kt">void</span> <span class="nf">UpdatePacketReceiveTimestamps</span><span class="p">(</span><span class="k">const</span> <span class="n">RtpPacketReceived</span><span class="o">&amp;</span> <span class="n">packet</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                                     <span class="kt">bool</span> <span class="n">is_keyframe</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">      <span class="n">RTC_RUN_ON</span><span class="p">(</span><span class="n">packet_sequence_checker_</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">const</span> <span class="n">FieldTrialsView</span><span class="o">&amp;</span> <span class="n">field_trials_</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">TaskQueueBase</span><span class="o">*</span> <span class="k">const</span> <span class="n">worker_queue_</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">Clock</span><span class="o">*</span> <span class="k">const</span> <span class="n">clock_</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// Ownership of this object lies with VideoReceiveStreamInterface, which owns
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// `this`.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">const</span> <span class="n">VideoReceiveStreamInterface</span><span class="o">::</span><span class="n">Config</span><span class="o">&amp;</span> <span class="n">config_</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">PacketRouter</span><span class="o">*</span> <span class="k">const</span> <span class="n">packet_router_</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">RemoteNtpTimeEstimator</span> <span class="n">ntp_estimator_</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// Set by the field trial WebRTC-ForcePlayoutDelay to override any playout
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// delay that is specified in the received packets.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">FieldTrialOptional</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">forced_playout_delay_max_ms_</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">FieldTrialOptional</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">forced_playout_delay_min_ms_</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">ReceiveStatistics</span><span class="o">*</span> <span class="k">const</span> <span class="n">rtp_receive_statistics_</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">UlpfecReceiver</span><span class="o">&gt;</span> <span class="n">ulpfec_receiver_</span>
</span></span><span class="line"><span class="cl">      <span class="n">RTC_GUARDED_BY</span><span class="p">(</span><span class="n">packet_sequence_checker_</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="kt">int</span> <span class="n">red_payload_type_</span> <span class="nf">RTC_GUARDED_BY</span><span class="p">(</span><span class="n">packet_sequence_checker_</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">RTC_NO_UNIQUE_ADDRESS</span> <span class="n">SequenceChecker</span> <span class="n">worker_task_checker_</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// TODO(bugs.webrtc.org/11993): This checker conceptually represents
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// operations that belong to the network thread. The Call class is currently
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// moving towards handling network packets on the network thread and while
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// that work is ongoing, this checker may in practice represent the worker
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// thread, but still serves as a mechanism of grouping together concepts
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// that belong to the network thread. Once the packets are fully delivered
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// on the network thread, this comment will be deleted.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">RTC_NO_UNIQUE_ADDRESS</span> <span class="n">SequenceChecker</span> <span class="n">packet_sequence_checker_</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">RtpPacketSinkInterface</span><span class="o">*</span> <span class="n">packet_sink_</span> <span class="nf">RTC_GUARDED_BY</span><span class="p">(</span><span class="n">packet_sequence_checker_</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="kt">bool</span> <span class="n">receiving_</span> <span class="nf">RTC_GUARDED_BY</span><span class="p">(</span><span class="n">packet_sequence_checker_</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="kt">int64_t</span> <span class="n">last_packet_log_ms_</span> <span class="nf">RTC_GUARDED_BY</span><span class="p">(</span><span class="n">packet_sequence_checker_</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">ModuleRtpRtcpImpl2</span><span class="o">&gt;</span> <span class="n">rtp_rtcp_</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">NackPeriodicProcessor</span><span class="o">*</span> <span class="k">const</span> <span class="n">nack_periodic_processor_</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">OnCompleteFrameCallback</span><span class="o">*</span> <span class="n">complete_frame_callback_</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">const</span> <span class="n">KeyFrameReqMethod</span> <span class="n">keyframe_request_method_</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">RtcpFeedbackBuffer</span> <span class="n">rtcp_feedback_buffer_</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// TODO(tommi): Consider absl::optional&lt;NackRequester&gt; instead of unique_ptr
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// since nack is usually configured.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">NackRequester</span><span class="o">&gt;</span> <span class="n">nack_module_</span>
</span></span><span class="line"><span class="cl">      <span class="n">RTC_GUARDED_BY</span><span class="p">(</span><span class="n">packet_sequence_checker_</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">LossNotificationController</span><span class="o">&gt;</span> <span class="n">loss_notification_controller_</span>
</span></span><span class="line"><span class="cl">      <span class="n">RTC_GUARDED_BY</span><span class="p">(</span><span class="n">packet_sequence_checker_</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">video_coding</span><span class="o">::</span><span class="n">PacketBuffer</span> <span class="n">packet_buffer_</span>
</span></span><span class="line"><span class="cl">      <span class="n">RTC_GUARDED_BY</span><span class="p">(</span><span class="n">packet_sequence_checker_</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// h26x_packet_buffer_ is nullptr if codec list doens&#39;t contain H.264 or
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// H.265, or field trial WebRTC-Video-H26xPacketBuffer is not enabled.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">H26xPacketBuffer</span><span class="o">&gt;</span> <span class="n">h26x_packet_buffer_</span>
</span></span><span class="line"><span class="cl">      <span class="n">RTC_GUARDED_BY</span><span class="p">(</span><span class="n">packet_sequence_checker_</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">UniqueTimestampCounter</span> <span class="n">frame_counter_</span>
</span></span><span class="line"><span class="cl">      <span class="nf">RTC_GUARDED_BY</span><span class="p">(</span><span class="n">packet_sequence_checker_</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">SeqNumUnwrapper</span><span class="o">&lt;</span><span class="kt">uint16_t</span><span class="o">&gt;</span> <span class="n">frame_id_unwrapper_</span>
</span></span><span class="line"><span class="cl">      <span class="n">RTC_GUARDED_BY</span><span class="p">(</span><span class="n">packet_sequence_checker_</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// Video structure provided in the dependency descriptor in a first packet
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// of a key frame. It is required to parse dependency descriptor in the
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// following delta packets.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">FrameDependencyStructure</span><span class="o">&gt;</span> <span class="n">video_structure_</span>
</span></span><span class="line"><span class="cl">      <span class="n">RTC_GUARDED_BY</span><span class="p">(</span><span class="n">packet_sequence_checker_</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// Frame id of the last frame with the attached video structure.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// absl::nullopt when `video_structure_ == nullptr`;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">absl</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="kt">int64_t</span><span class="o">&gt;</span> <span class="n">video_structure_frame_id_</span>
</span></span><span class="line"><span class="cl">      <span class="n">RTC_GUARDED_BY</span><span class="p">(</span><span class="n">packet_sequence_checker_</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">Timestamp</span> <span class="n">last_logged_failed_to_parse_dd_</span>
</span></span><span class="line"><span class="cl">      <span class="nf">RTC_GUARDED_BY</span><span class="p">(</span><span class="n">packet_sequence_checker_</span><span class="p">)</span> <span class="o">=</span> <span class="n">Timestamp</span><span class="o">::</span><span class="n">MinusInfinity</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">RtpFrameReferenceFinder</span><span class="o">&gt;</span> <span class="n">reference_finder_</span>
</span></span><span class="line"><span class="cl">      <span class="n">RTC_GUARDED_BY</span><span class="p">(</span><span class="n">packet_sequence_checker_</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">absl</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="n">VideoCodecType</span><span class="o">&gt;</span> <span class="n">current_codec_</span>
</span></span><span class="line"><span class="cl">      <span class="n">RTC_GUARDED_BY</span><span class="p">(</span><span class="n">packet_sequence_checker_</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="kt">uint32_t</span> <span class="n">last_assembled_frame_rtp_timestamp_</span>
</span></span><span class="line"><span class="cl">      <span class="nf">RTC_GUARDED_BY</span><span class="p">(</span><span class="n">packet_sequence_checker_</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span><span class="kt">int64_t</span><span class="p">,</span> <span class="kt">uint16_t</span><span class="o">&gt;</span> <span class="n">last_seq_num_for_pic_id_</span>
</span></span><span class="line"><span class="cl">      <span class="n">RTC_GUARDED_BY</span><span class="p">(</span><span class="n">packet_sequence_checker_</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">video_coding</span><span class="o">::</span><span class="n">H264SpsPpsTracker</span> <span class="n">tracker_</span>
</span></span><span class="line"><span class="cl">      <span class="n">RTC_GUARDED_BY</span><span class="p">(</span><span class="n">packet_sequence_checker_</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// Maps payload id to the depacketizer.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span><span class="kt">uint8_t</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">VideoRtpDepacketizer</span><span class="o">&gt;&gt;</span> <span class="n">payload_type_map_</span>
</span></span><span class="line"><span class="cl">      <span class="n">RTC_GUARDED_BY</span><span class="p">(</span><span class="n">packet_sequence_checker_</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// TODO(johan): Remove pt_codec_params_ once
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// https://bugs.chromium.org/p/webrtc/issues/detail?id=6883 is resolved.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// Maps a payload type to a map of out-of-band supplied codec parameters.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span><span class="kt">uint8_t</span><span class="p">,</span> <span class="n">webrtc</span><span class="o">::</span><span class="n">CodecParameterMap</span><span class="o">&gt;</span> <span class="n">pt_codec_params_</span>
</span></span><span class="line"><span class="cl">      <span class="n">RTC_GUARDED_BY</span><span class="p">(</span><span class="n">packet_sequence_checker_</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="kt">int16_t</span> <span class="n">last_payload_type_</span> <span class="nf">RTC_GUARDED_BY</span><span class="p">(</span><span class="n">packet_sequence_checker_</span><span class="p">)</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="kt">bool</span> <span class="n">has_received_frame_</span> <span class="nf">RTC_GUARDED_BY</span><span class="p">(</span><span class="n">packet_sequence_checker_</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">absl</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="kt">uint32_t</span><span class="o">&gt;</span> <span class="n">last_received_rtp_timestamp_</span>
</span></span><span class="line"><span class="cl">      <span class="n">RTC_GUARDED_BY</span><span class="p">(</span><span class="n">packet_sequence_checker_</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">absl</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="kt">uint32_t</span><span class="o">&gt;</span> <span class="n">last_received_keyframe_rtp_timestamp_</span>
</span></span><span class="line"><span class="cl">      <span class="n">RTC_GUARDED_BY</span><span class="p">(</span><span class="n">packet_sequence_checker_</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">absl</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="n">Timestamp</span><span class="o">&gt;</span> <span class="n">last_received_rtp_system_time_</span>
</span></span><span class="line"><span class="cl">      <span class="n">RTC_GUARDED_BY</span><span class="p">(</span><span class="n">packet_sequence_checker_</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">absl</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="n">Timestamp</span><span class="o">&gt;</span> <span class="n">last_received_keyframe_rtp_system_time_</span>
</span></span><span class="line"><span class="cl">      <span class="n">RTC_GUARDED_BY</span><span class="p">(</span><span class="n">packet_sequence_checker_</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// Handles incoming encrypted frames and forwards them to the
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// rtp_reference_finder if they are decryptable.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">BufferedFrameDecryptor</span><span class="o">&gt;</span> <span class="n">buffered_frame_decryptor_</span>
</span></span><span class="line"><span class="cl">      <span class="n">RTC_PT_GUARDED_BY</span><span class="p">(</span><span class="n">packet_sequence_checker_</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="kt">bool</span> <span class="n">frames_decryptable_</span> <span class="nf">RTC_GUARDED_BY</span><span class="p">(</span><span class="n">worker_task_checker_</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">absl</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="n">ColorSpace</span><span class="o">&gt;</span> <span class="n">last_color_space_</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">AbsoluteCaptureTimeInterpolator</span> <span class="n">absolute_capture_time_interpolator_</span>
</span></span><span class="line"><span class="cl">      <span class="nf">RTC_GUARDED_BY</span><span class="p">(</span><span class="n">packet_sequence_checker_</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">CaptureClockOffsetUpdater</span> <span class="n">capture_clock_offset_updater_</span>
</span></span><span class="line"><span class="cl">      <span class="nf">RTC_GUARDED_BY</span><span class="p">(</span><span class="n">packet_sequence_checker_</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="kt">int64_t</span> <span class="n">last_completed_picture_id_</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">rtc</span><span class="o">::</span><span class="n">scoped_refptr</span><span class="o">&lt;</span><span class="n">RtpVideoStreamReceiverFrameTransformerDelegate</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl">      <span class="n">frame_transformer_delegate_</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">SeqNumUnwrapper</span><span class="o">&lt;</span><span class="kt">uint16_t</span><span class="o">&gt;</span> <span class="n">rtp_seq_num_unwrapper_</span>
</span></span><span class="line"><span class="cl">      <span class="n">RTC_GUARDED_BY</span><span class="p">(</span><span class="n">packet_sequence_checker_</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span><span class="kt">int64_t</span><span class="p">,</span> <span class="n">RtpPacketInfo</span><span class="o">&gt;</span> <span class="n">packet_infos_</span>
</span></span><span class="line"><span class="cl">      <span class="n">RTC_GUARDED_BY</span><span class="p">(</span><span class="n">packet_sequence_checker_</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">RtpPacketReceived</span><span class="o">&gt;</span> <span class="n">stashed_packets_</span>
</span></span><span class="line"><span class="cl">      <span class="n">RTC_GUARDED_BY</span><span class="p">(</span><span class="n">packet_sequence_checker_</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">Timestamp</span> <span class="n">next_keyframe_request_for_missing_video_structure_</span> <span class="o">=</span>
</span></span><span class="line"><span class="cl">      <span class="n">Timestamp</span><span class="o">::</span><span class="n">MinusInfinity</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="kt">bool</span> <span class="n">sps_pps_idr_is_h264_keyframe_</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></div><p>其中的<code>OnRtpPacket</code>方法实现了<code>RtpPacketSinkInterface</code>这一接口，负责完成前面提到的 buffer 的第一个工作内容：接收 rtp 包。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="c1">// This method handles both regular RTP packets and packets recovered
</span></span></span><span class="line"><span class="cl"><span class="c1">// via FlexFEC.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">void</span> <span class="n">RtpVideoStreamReceiver2</span><span class="o">::</span><span class="n">OnRtpPacket</span><span class="p">(</span><span class="k">const</span> <span class="n">RtpPacketReceived</span><span class="o">&amp;</span> <span class="n">packet</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">RTC_DCHECK_RUN_ON</span><span class="p">(</span><span class="o">&amp;</span><span class="n">packet_sequence_checker_</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">receiving_</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">ReceivePacket</span><span class="p">(</span><span class="n">packet</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// Update receive statistics after ReceivePacket.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// Receive statistics will be reset if the payload type changes (make sure
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// that the first packet is included in the stats).
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">packet</span><span class="p">.</span><span class="n">recovered</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">rtp_receive_statistics_</span><span class="o">-&gt;</span><span class="n">OnRtpPacket</span><span class="p">(</span><span class="n">packet</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="n">packet_sink_</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">packet_sink_</span><span class="o">-&gt;</span><span class="n">OnRtpPacket</span><span class="p">(</span><span class="n">packet</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>其中，用于接收普通 rtp 包的方法为<code>ReceivePacket</code>：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">RtpVideoStreamReceiver2</span><span class="o">::</span><span class="n">ReceivePacket</span><span class="p">(</span><span class="k">const</span> <span class="n">RtpPacketReceived</span><span class="o">&amp;</span> <span class="n">packet</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">RTC_DCHECK_RUN_ON</span><span class="p">(</span><span class="o">&amp;</span><span class="n">packet_sequence_checker_</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="n">packet</span><span class="p">.</span><span class="n">payload_size</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// Padding or keep-alive packet.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// TODO(nisse): Could drop empty packets earlier, but need to figure out how
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// they should be counted in stats.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">NotifyReceiverOfEmptyPacket</span><span class="p">(</span><span class="n">packet</span><span class="p">.</span><span class="n">SequenceNumber</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="n">packet</span><span class="p">.</span><span class="n">PayloadType</span><span class="p">()</span> <span class="o">==</span> <span class="n">red_payload_type_</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">ParseAndHandleEncapsulatingHeader</span><span class="p">(</span><span class="n">packet</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">const</span> <span class="k">auto</span> <span class="n">type_it</span> <span class="o">=</span> <span class="n">payload_type_map_</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">packet</span><span class="p">.</span><span class="n">PayloadType</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="n">type_it</span> <span class="o">==</span> <span class="n">payload_type_map_</span><span class="p">.</span><span class="n">end</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">auto</span> <span class="n">parse_and_insert</span> <span class="o">=</span> <span class="p">[</span><span class="o">&amp;</span><span class="p">](</span><span class="k">const</span> <span class="n">RtpPacketReceived</span><span class="o">&amp;</span> <span class="n">packet</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">RTC_DCHECK_RUN_ON</span><span class="p">(</span><span class="o">&amp;</span><span class="n">packet_sequence_checker_</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">absl</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="n">VideoRtpDepacketizer</span><span class="o">::</span><span class="n">ParsedRtpPayload</span><span class="o">&gt;</span> <span class="n">parsed_payload</span> <span class="o">=</span>
</span></span><span class="line"><span class="cl">        <span class="n">type_it</span><span class="o">-&gt;</span><span class="n">second</span><span class="o">-&gt;</span><span class="n">Parse</span><span class="p">(</span><span class="n">packet</span><span class="p">.</span><span class="n">PayloadBuffer</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">parsed_payload</span> <span class="o">==</span> <span class="n">absl</span><span class="o">::</span><span class="n">nullopt</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">RTC_LOG</span><span class="p">(</span><span class="n">LS_WARNING</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Failed parsing payload.&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">times_nacked</span> <span class="o">=</span> <span class="n">nack_module_</span>
</span></span><span class="line"><span class="cl">                           <span class="o">?</span> <span class="n">nack_module_</span><span class="o">-&gt;</span><span class="n">OnReceivedPacket</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">                                 <span class="n">packet</span><span class="p">.</span><span class="n">SequenceNumber</span><span class="p">(),</span> <span class="n">packet</span><span class="p">.</span><span class="n">recovered</span><span class="p">())</span>
</span></span><span class="line"><span class="cl">                           <span class="o">:</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nf">OnReceivedPayloadData</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">parsed_payload</span><span class="o">-&gt;</span><span class="n">video_payload</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">                                 <span class="n">packet</span><span class="p">,</span> <span class="n">parsed_payload</span><span class="o">-&gt;</span><span class="n">video_header</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                                 <span class="n">times_nacked</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// When the dependency descriptor is used and the descriptor fail to parse
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// then `OnReceivedPayloadData` may return true to signal the the packet
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// should be retried at a later stage, which is why they are stashed here.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// TODO(bugs.webrtc.org/15782):
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// This is an ugly solution. The way things should work is for the
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// `RtpFrameReferenceFinder` to stash assembled frames until the keyframe with
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// the relevant template structure has been received, but unfortunately the
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// `frame_transformer_delegate_` is called before the frames are inserted into
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// the `RtpFrameReferenceFinder`, and it expects the dependency descriptor to
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// be parsed at that stage.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">if</span> <span class="p">(</span><span class="n">parse_and_insert</span><span class="p">(</span><span class="n">packet</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">stashed_packets_</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">==</span> <span class="mi">100</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">stashed_packets_</span><span class="p">.</span><span class="n">clear</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="n">stashed_packets_</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">packet</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="n">it</span> <span class="o">=</span> <span class="n">stashed_packets_</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span> <span class="n">it</span> <span class="o">!=</span> <span class="n">stashed_packets_</span><span class="p">.</span><span class="n">end</span><span class="p">();)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">if</span> <span class="p">(</span><span class="n">parse_and_insert</span><span class="p">(</span><span class="o">*</span><span class="n">it</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="o">++</span><span class="n">it</span><span class="p">;</span>  <span class="c1">// keep in the stash.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">it</span> <span class="o">=</span> <span class="n">stashed_packets_</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">it</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>在<code>parse_and_insert()</code>中，首先将 packet 的<code>PayloadBuffer</code>移动到<code>parsed_payload</code>中，并且计算发送的 nack 的数量，然后将<code>parsed_payload</code>和<code>times_nacked</code>传入<code>OnReceivedPayloadData</code>来完成真正的 packet 解析和 frame 组装的工作。在下面<code>parse_and_insert</code>的使用过程，其实就是利用一个大小为 100 的 vector 来完成递归解析和组装属于同一个 frame 的 packet 的过程。这里的<code>OnReceivedPayloadData</code>的返回值表示的就是当前 packet 所属的帧有没有被解析完。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">bool</span> <span class="n">RtpVideoStreamReceiver2</span><span class="o">::</span><span class="n">OnReceivedPayloadData</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="n">rtc</span><span class="o">::</span><span class="n">CopyOnWriteBuffer</span> <span class="n">codec_payload</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="k">const</span> <span class="n">RtpPacketReceived</span><span class="o">&amp;</span> <span class="n">rtp_packet</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="k">const</span> <span class="n">RTPVideoHeader</span><span class="o">&amp;</span> <span class="n">video</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">times_nacked</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">RTC_DCHECK_RUN_ON</span><span class="p">(</span><span class="o">&amp;</span><span class="n">packet_sequence_checker_</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">auto</span> <span class="n">packet</span> <span class="o">=</span>
</span></span><span class="line"><span class="cl">      <span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">video_coding</span><span class="o">::</span><span class="n">PacketBuffer</span><span class="o">::</span><span class="n">Packet</span><span class="o">&gt;</span><span class="p">(</span><span class="n">rtp_packet</span><span class="p">,</span> <span class="n">video</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="kt">int64_t</span> <span class="n">unwrapped_rtp_seq_num</span> <span class="o">=</span>
</span></span><span class="line"><span class="cl">      <span class="n">rtp_seq_num_unwrapper_</span><span class="p">.</span><span class="n">Unwrap</span><span class="p">(</span><span class="n">rtp_packet</span><span class="p">.</span><span class="n">SequenceNumber</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">RtpPacketInfo</span><span class="o">&amp;</span> <span class="n">packet_info</span> <span class="o">=</span>
</span></span><span class="line"><span class="cl">      <span class="n">packet_infos_</span>
</span></span><span class="line"><span class="cl">          <span class="p">.</span><span class="n">emplace</span><span class="p">(</span><span class="n">unwrapped_rtp_seq_num</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                   <span class="n">RtpPacketInfo</span><span class="p">(</span><span class="n">rtp_packet</span><span class="p">.</span><span class="n">Ssrc</span><span class="p">(),</span> <span class="n">rtp_packet</span><span class="p">.</span><span class="n">Csrcs</span><span class="p">(),</span>
</span></span><span class="line"><span class="cl">                                 <span class="n">rtp_packet</span><span class="p">.</span><span class="n">Timestamp</span><span class="p">(),</span>
</span></span><span class="line"><span class="cl">                                 <span class="cm">/*receive_time_ms=*/</span><span class="n">clock_</span><span class="o">-&gt;</span><span class="n">CurrentTime</span><span class="p">()))</span>
</span></span><span class="line"><span class="cl">          <span class="p">.</span><span class="n">first</span><span class="o">-&gt;</span><span class="n">second</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// Try to extrapolate absolute capture time if it is missing.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">packet_info</span><span class="p">.</span><span class="n">set_absolute_capture_time</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">      <span class="n">absolute_capture_time_interpolator_</span><span class="p">.</span><span class="n">OnReceivePacket</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">          <span class="n">AbsoluteCaptureTimeInterpolator</span><span class="o">::</span><span class="n">GetSource</span><span class="p">(</span><span class="n">packet_info</span><span class="p">.</span><span class="n">ssrc</span><span class="p">(),</span>
</span></span><span class="line"><span class="cl">                                                     <span class="n">packet_info</span><span class="p">.</span><span class="n">csrcs</span><span class="p">()),</span>
</span></span><span class="line"><span class="cl">          <span class="n">packet_info</span><span class="p">.</span><span class="n">rtp_timestamp</span><span class="p">(),</span>
</span></span><span class="line"><span class="cl">          <span class="c1">// Assume frequency is the same one for all video frames.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>          <span class="n">kVideoPayloadTypeFrequency</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">          <span class="n">rtp_packet</span><span class="p">.</span><span class="n">GetExtension</span><span class="o">&lt;</span><span class="n">AbsoluteCaptureTimeExtension</span><span class="o">&gt;</span><span class="p">()));</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="n">packet_info</span><span class="p">.</span><span class="n">absolute_capture_time</span><span class="p">().</span><span class="n">has_value</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">packet_info</span><span class="p">.</span><span class="n">set_local_capture_clock_offset</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">        <span class="n">capture_clock_offset_updater_</span><span class="p">.</span><span class="n">ConvertsToTimeDela</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">            <span class="n">capture_clock_offset_updater_</span><span class="p">.</span><span class="n">AdjustEstimatedCaptureClockOffset</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">                <span class="n">packet_info</span><span class="p">.</span><span class="n">absolute_capture_time</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">                    <span class="o">-&gt;</span><span class="n">estimated_capture_clock_offset</span><span class="p">)));</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="n">RTPVideoHeader</span><span class="o">&amp;</span> <span class="n">video_header</span> <span class="o">=</span> <span class="n">packet</span><span class="o">-&gt;</span><span class="n">video_header</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">video_header</span><span class="p">.</span><span class="n">rotation</span> <span class="o">=</span> <span class="n">kVideoRotation_0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">video_header</span><span class="p">.</span><span class="n">content_type</span> <span class="o">=</span> <span class="n">VideoContentType</span><span class="o">::</span><span class="n">UNSPECIFIED</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">video_header</span><span class="p">.</span><span class="n">video_timing</span><span class="p">.</span><span class="n">flags</span> <span class="o">=</span> <span class="n">VideoSendTiming</span><span class="o">::</span><span class="n">kInvalid</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">video_header</span><span class="p">.</span><span class="n">is_last_packet_in_frame</span> <span class="o">|=</span> <span class="n">rtp_packet</span><span class="p">.</span><span class="n">Marker</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">rtp_packet</span><span class="p">.</span><span class="n">GetExtension</span><span class="o">&lt;</span><span class="n">VideoOrientation</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="n">video_header</span><span class="p">.</span><span class="n">rotation</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">rtp_packet</span><span class="p">.</span><span class="n">GetExtension</span><span class="o">&lt;</span><span class="n">VideoContentTypeExtension</span><span class="o">&gt;</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">      <span class="o">&amp;</span><span class="n">video_header</span><span class="p">.</span><span class="n">content_type</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">rtp_packet</span><span class="p">.</span><span class="n">GetExtension</span><span class="o">&lt;</span><span class="n">VideoTimingExtension</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="n">video_header</span><span class="p">.</span><span class="n">video_timing</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="n">forced_playout_delay_max_ms_</span> <span class="o">&amp;&amp;</span> <span class="n">forced_playout_delay_min_ms_</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">video_header</span><span class="p">.</span><span class="n">playout_delay</span><span class="p">.</span><span class="n">emplace</span><span class="p">().</span><span class="n">Set</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">            <span class="n">TimeDelta</span><span class="o">::</span><span class="n">Millis</span><span class="p">(</span><span class="o">*</span><span class="n">forced_playout_delay_min_ms_</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">            <span class="n">TimeDelta</span><span class="o">::</span><span class="n">Millis</span><span class="p">(</span><span class="o">*</span><span class="n">forced_playout_delay_max_ms_</span><span class="p">)))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">video_header</span><span class="p">.</span><span class="n">playout_delay</span> <span class="o">=</span> <span class="n">absl</span><span class="o">::</span><span class="n">nullopt</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">video_header</span><span class="p">.</span><span class="n">playout_delay</span> <span class="o">=</span> <span class="n">rtp_packet</span><span class="p">.</span><span class="n">GetExtension</span><span class="o">&lt;</span><span class="n">PlayoutDelayLimits</span><span class="o">&gt;</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rtp_packet</span><span class="p">.</span><span class="n">recovered</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">UpdatePacketReceiveTimestamps</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">        <span class="n">rtp_packet</span><span class="p">,</span> <span class="n">video_header</span><span class="p">.</span><span class="n">frame_type</span> <span class="o">==</span> <span class="n">VideoFrameType</span><span class="o">::</span><span class="n">kVideoFrameKey</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">ParseGenericDependenciesResult</span> <span class="n">generic_descriptor_state</span> <span class="o">=</span>
</span></span><span class="line"><span class="cl">      <span class="n">ParseGenericDependenciesExtension</span><span class="p">(</span><span class="n">rtp_packet</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">video_header</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="n">generic_descriptor_state</span> <span class="o">==</span> <span class="n">kStashPacket</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span> <span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="n">generic_descriptor_state</span> <span class="o">==</span> <span class="n">kDropPacket</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">Timestamp</span> <span class="n">now</span> <span class="o">=</span> <span class="n">clock_</span><span class="o">-&gt;</span><span class="n">CurrentTime</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">now</span> <span class="o">-</span> <span class="n">last_logged_failed_to_parse_dd_</span> <span class="o">&gt;</span> <span class="n">TimeDelta</span><span class="o">::</span><span class="n">Seconds</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">last_logged_failed_to_parse_dd_</span> <span class="o">=</span> <span class="n">now</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="n">RTC_LOG</span><span class="p">(</span><span class="n">LS_WARNING</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;ssrc: &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">rtp_packet</span><span class="p">.</span><span class="n">Ssrc</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">                          <span class="o">&lt;&lt;</span> <span class="s">&#34; Failed to parse dependency descriptor.&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">video_structure_</span> <span class="o">==</span> <span class="k">nullptr</span> <span class="o">&amp;&amp;</span>
</span></span><span class="line"><span class="cl">        <span class="n">next_keyframe_request_for_missing_video_structure_</span> <span class="o">&lt;</span> <span class="n">now</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="c1">// No video structure received yet, most likely part of the initial
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="c1">// keyframe was lost.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="n">RequestKeyFrame</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">      <span class="n">next_keyframe_request_for_missing_video_structure_</span> <span class="o">=</span>
</span></span><span class="line"><span class="cl">          <span class="n">now</span> <span class="o">+</span> <span class="n">TimeDelta</span><span class="o">::</span><span class="n">Seconds</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// Color space should only be transmitted in the last packet of a frame,
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// therefore, neglect it otherwise so that last_color_space_ is not reset by
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// mistake.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">if</span> <span class="p">(</span><span class="n">video_header</span><span class="p">.</span><span class="n">is_last_packet_in_frame</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">video_header</span><span class="p">.</span><span class="n">color_space</span> <span class="o">=</span> <span class="n">rtp_packet</span><span class="p">.</span><span class="n">GetExtension</span><span class="o">&lt;</span><span class="n">ColorSpaceExtension</span><span class="o">&gt;</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">video_header</span><span class="p">.</span><span class="n">color_space</span> <span class="o">||</span>
</span></span><span class="line"><span class="cl">        <span class="n">video_header</span><span class="p">.</span><span class="n">frame_type</span> <span class="o">==</span> <span class="n">VideoFrameType</span><span class="o">::</span><span class="n">kVideoFrameKey</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="c1">// Store color space since it&#39;s only transmitted when changed or for key
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="c1">// frames. Color space will be cleared if a key frame is transmitted
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="c1">// without color space information.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="n">last_color_space_</span> <span class="o">=</span> <span class="n">video_header</span><span class="p">.</span><span class="n">color_space</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span> <span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="n">last_color_space_</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">video_header</span><span class="p">.</span><span class="n">color_space</span> <span class="o">=</span> <span class="n">last_color_space_</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="n">video_header</span><span class="p">.</span><span class="n">video_frame_tracking_id</span> <span class="o">=</span>
</span></span><span class="line"><span class="cl">      <span class="n">rtp_packet</span><span class="p">.</span><span class="n">GetExtension</span><span class="o">&lt;</span><span class="n">VideoFrameTrackingIdExtension</span><span class="o">&gt;</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="n">loss_notification_controller_</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">rtp_packet</span><span class="p">.</span><span class="n">recovered</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="c1">// TODO(bugs.webrtc.org/10336): Implement support for reordering.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="n">RTC_LOG</span><span class="p">(</span><span class="n">LS_INFO</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">          <span class="o">&lt;&lt;</span> <span class="s">&#34;LossNotificationController does not support reordering.&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span> <span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="n">generic_descriptor_state</span> <span class="o">==</span> <span class="n">kNoGenericDescriptor</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">RTC_LOG</span><span class="p">(</span><span class="n">LS_WARNING</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;LossNotificationController requires generic &#34;</span>
</span></span><span class="line"><span class="cl">                             <span class="s">&#34;frame descriptor, but it is missing.&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">if</span> <span class="p">(</span><span class="n">video_header</span><span class="p">.</span><span class="n">is_first_packet_in_frame</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">RTC_DCHECK</span><span class="p">(</span><span class="n">video_header</span><span class="p">.</span><span class="n">generic</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">LossNotificationController</span><span class="o">::</span><span class="n">FrameDetails</span> <span class="n">frame</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">frame</span><span class="p">.</span><span class="n">is_keyframe</span> <span class="o">=</span>
</span></span><span class="line"><span class="cl">            <span class="n">video_header</span><span class="p">.</span><span class="n">frame_type</span> <span class="o">==</span> <span class="n">VideoFrameType</span><span class="o">::</span><span class="n">kVideoFrameKey</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">frame</span><span class="p">.</span><span class="n">frame_id</span> <span class="o">=</span> <span class="n">video_header</span><span class="p">.</span><span class="n">generic</span><span class="o">-&gt;</span><span class="n">frame_id</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">frame</span><span class="p">.</span><span class="n">frame_dependencies</span> <span class="o">=</span> <span class="n">video_header</span><span class="p">.</span><span class="n">generic</span><span class="o">-&gt;</span><span class="n">dependencies</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">loss_notification_controller_</span><span class="o">-&gt;</span><span class="n">OnReceivedPacket</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">            <span class="n">rtp_packet</span><span class="p">.</span><span class="n">SequenceNumber</span><span class="p">(),</span> <span class="o">&amp;</span><span class="n">frame</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">loss_notification_controller_</span><span class="o">-&gt;</span><span class="n">OnReceivedPacket</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">            <span class="n">rtp_packet</span><span class="p">.</span><span class="n">SequenceNumber</span><span class="p">(),</span> <span class="k">nullptr</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">packet</span><span class="o">-&gt;</span><span class="n">times_nacked</span> <span class="o">=</span> <span class="n">times_nacked</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="n">codec_payload</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">NotifyReceiverOfEmptyPacket</span><span class="p">(</span><span class="n">packet</span><span class="o">-&gt;</span><span class="n">seq_num</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">rtcp_feedback_buffer_</span><span class="p">.</span><span class="n">SendBufferedRtcpFeedback</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="n">packet</span><span class="o">-&gt;</span><span class="n">codec</span><span class="p">()</span> <span class="o">==</span> <span class="n">kVideoCodecH264</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// Only when we start to receive packets will we know what payload type
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// that will be used. When we know the payload type insert the correct
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// sps/pps into the tracker.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">packet</span><span class="o">-&gt;</span><span class="n">payload_type</span> <span class="o">!=</span> <span class="n">last_payload_type_</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">last_payload_type_</span> <span class="o">=</span> <span class="n">packet</span><span class="o">-&gt;</span><span class="n">payload_type</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="n">InsertSpsPpsIntoTracker</span><span class="p">(</span><span class="n">packet</span><span class="o">-&gt;</span><span class="n">payload_type</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="n">packet</span><span class="o">-&gt;</span><span class="n">codec</span><span class="p">()</span> <span class="o">==</span> <span class="n">kVideoCodecH264</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">h26x_packet_buffer_</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">video_coding</span><span class="o">::</span><span class="n">H264SpsPpsTracker</span><span class="o">::</span><span class="n">FixedBitstream</span> <span class="n">fixed</span> <span class="o">=</span>
</span></span><span class="line"><span class="cl">        <span class="n">tracker_</span><span class="p">.</span><span class="n">CopyAndFixBitstream</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">            <span class="n">rtc</span><span class="o">::</span><span class="n">MakeArrayView</span><span class="p">(</span><span class="n">codec_payload</span><span class="p">.</span><span class="n">cdata</span><span class="p">(),</span> <span class="n">codec_payload</span><span class="p">.</span><span class="n">size</span><span class="p">()),</span>
</span></span><span class="line"><span class="cl">            <span class="o">&amp;</span><span class="n">packet</span><span class="o">-&gt;</span><span class="n">video_header</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">switch</span> <span class="p">(</span><span class="n">fixed</span><span class="p">.</span><span class="n">action</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">case</span> <span class="n">video_coding</span><span class="o">::</span><span class="n">H264SpsPpsTracker</span><span class="o">::</span><span class="nl">kRequestKeyframe</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="n">rtcp_feedback_buffer_</span><span class="p">.</span><span class="n">RequestKeyFrame</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">        <span class="n">rtcp_feedback_buffer_</span><span class="p">.</span><span class="n">SendBufferedRtcpFeedback</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">        <span class="na">[[fallthrough]]</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="k">case</span> <span class="n">video_coding</span><span class="o">::</span><span class="n">H264SpsPpsTracker</span><span class="o">::</span><span class="nl">kDrop</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="k">case</span> <span class="n">video_coding</span><span class="o">::</span><span class="n">H264SpsPpsTracker</span><span class="o">::</span><span class="nl">kInsert</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="n">packet</span><span class="o">-&gt;</span><span class="n">video_payload</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">fixed</span><span class="p">.</span><span class="n">bitstream</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">packet</span><span class="o">-&gt;</span><span class="n">video_payload</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">codec_payload</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">rtcp_feedback_buffer_</span><span class="p">.</span><span class="n">SendBufferedRtcpFeedback</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="n">frame_counter_</span><span class="p">.</span><span class="n">Add</span><span class="p">(</span><span class="n">packet</span><span class="o">-&gt;</span><span class="n">timestamp</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">((</span><span class="n">packet</span><span class="o">-&gt;</span><span class="n">codec</span><span class="p">()</span> <span class="o">==</span> <span class="n">kVideoCodecH264</span> <span class="o">||</span>
</span></span><span class="line"><span class="cl">       <span class="n">packet</span><span class="o">-&gt;</span><span class="n">codec</span><span class="p">()</span> <span class="o">==</span> <span class="n">kVideoCodecH265</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
</span></span><span class="line"><span class="cl">      <span class="n">h26x_packet_buffer_</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">OnInsertedPacket</span><span class="p">(</span><span class="n">h26x_packet_buffer_</span><span class="o">-&gt;</span><span class="n">InsertPacket</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">packet</span><span class="p">)));</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">OnInsertedPacket</span><span class="p">(</span><span class="n">packet_buffer_</span><span class="p">.</span><span class="n">InsertPacket</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">packet</span><span class="p">)));</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>这个方法的核心判断的逻辑在于利用<code>ParseGenericDependenciesExtension</code>来判断当前 packet 的依赖类型，对于正常的依赖类型<code>kHasGenericDescriptor</code>，调用<code>InsertPacket</code>将 packet 插入到<code>PacketBuffer</code>中，并将<code>InsertPacket</code>的返回值作为<code>OnInsertedPacket</code>的参数来组帧。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">PacketBuffer</span><span class="o">::</span><span class="n">InsertResult</span> <span class="n">PacketBuffer</span><span class="o">::</span><span class="n">InsertPacket</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">PacketBuffer</span><span class="o">::</span><span class="n">Packet</span><span class="o">&gt;</span> <span class="n">packet</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">PacketBuffer</span><span class="o">::</span><span class="n">InsertResult</span> <span class="n">result</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="kt">uint16_t</span> <span class="n">seq_num</span> <span class="o">=</span> <span class="n">packet</span><span class="o">-&gt;</span><span class="n">seq_num</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">size_t</span> <span class="n">index</span> <span class="o">=</span> <span class="n">seq_num</span> <span class="o">%</span> <span class="n">buffer_</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">first_packet_received_</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">first_seq_num_</span> <span class="o">=</span> <span class="n">seq_num</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">first_packet_received_</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span> <span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="n">AheadOf</span><span class="p">(</span><span class="n">first_seq_num_</span><span class="p">,</span> <span class="n">seq_num</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// If we have explicitly cleared past this packet then it&#39;s old,
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// don&#39;t insert it, just silently ignore it.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">is_cleared_to_first_seq_num_</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">ForwardDiff</span><span class="o">&lt;</span><span class="kt">uint16_t</span><span class="o">&gt;</span><span class="p">(</span><span class="n">first_seq_num_</span><span class="p">,</span> <span class="n">seq_num</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">max_size_</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="c1">// Large negative jump in rtp sequence number: clear the buffer and treat
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="c1">// latest packet as the new first packet.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="n">Clear</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">      <span class="n">first_packet_received_</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">first_seq_num_</span> <span class="o">=</span> <span class="n">seq_num</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="n">buffer_</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">!=</span> <span class="k">nullptr</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// Duplicate packet, just delete the payload.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">buffer_</span><span class="p">[</span><span class="n">index</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">seq_num</span> <span class="o">==</span> <span class="n">packet</span><span class="o">-&gt;</span><span class="n">seq_num</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// The packet buffer is full, try to expand the buffer.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">while</span> <span class="p">(</span><span class="n">ExpandBufferSize</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">buffer_</span><span class="p">[</span><span class="n">seq_num</span> <span class="o">%</span> <span class="n">buffer_</span><span class="p">.</span><span class="n">size</span><span class="p">()]</span> <span class="o">!=</span> <span class="k">nullptr</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="n">index</span> <span class="o">=</span> <span class="n">seq_num</span> <span class="o">%</span> <span class="n">buffer_</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// Packet buffer is still full since we were unable to expand the buffer.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">buffer_</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">!=</span> <span class="k">nullptr</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="c1">// Clear the buffer, delete payload, and return false to signal that a
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="c1">// new keyframe is needed.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="n">RTC_LOG</span><span class="p">(</span><span class="n">LS_WARNING</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Clear PacketBuffer and request key frame.&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="n">ClearInternal</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">      <span class="n">result</span><span class="p">.</span><span class="n">buffer_cleared</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">packet</span><span class="o">-&gt;</span><span class="n">continuous</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">buffer_</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">packet</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">UpdateMissingPackets</span><span class="p">(</span><span class="n">seq_num</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">received_padding_</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">      <span class="n">received_padding_</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span>
</span></span><span class="line"><span class="cl">      <span class="n">received_padding_</span><span class="p">.</span><span class="n">lower_bound</span><span class="p">(</span><span class="n">seq_num</span> <span class="o">-</span> <span class="p">(</span><span class="n">buffer_</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">/</span> <span class="mi">4</span><span class="p">)));</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">result</span><span class="p">.</span><span class="n">packets</span> <span class="o">=</span> <span class="n">FindFrames</span><span class="p">(</span><span class="n">seq_num</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p><code>InsertPacket</code>的过程其实就是：首先判断是不是当前 packet 首包，是的话就记录一下，接下来的包开始往后排序，不是的话就调用包序列号比较函数 AheadOf。在利用索引计算的包在缓存中的位置如果被占用并且序列号一样，就是重复包，丢掉。如果被占用但是序列号不相同，就说明缓存满了，需要扩容，重新计算包的索引值，扩容后还是满的就要情况缓存了。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">PacketBuffer</span><span class="o">::</span><span class="n">UpdateMissingPackets</span><span class="p">(</span><span class="kt">uint16_t</span> <span class="n">seq_num</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">newest_inserted_seq_num_</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="n">newest_inserted_seq_num_</span> <span class="o">=</span> <span class="n">seq_num</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">const</span> <span class="kt">int</span> <span class="n">kMaxPaddingAge</span> <span class="o">=</span> <span class="mi">1000</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="n">AheadOf</span><span class="p">(</span><span class="n">seq_num</span><span class="p">,</span> <span class="o">*</span><span class="n">newest_inserted_seq_num_</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">uint16_t</span> <span class="n">old_seq_num</span> <span class="o">=</span> <span class="n">seq_num</span> <span class="o">-</span> <span class="n">kMaxPaddingAge</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">auto</span> <span class="n">erase_to</span> <span class="o">=</span> <span class="n">missing_packets_</span><span class="p">.</span><span class="n">lower_bound</span><span class="p">(</span><span class="n">old_seq_num</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">missing_packets_</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">missing_packets_</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">erase_to</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// Guard against inserting a large amount of missing packets if there is a
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// jump in the sequence number.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">AheadOf</span><span class="p">(</span><span class="n">old_seq_num</span><span class="p">,</span> <span class="o">*</span><span class="n">newest_inserted_seq_num_</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">      <span class="o">*</span><span class="n">newest_inserted_seq_num_</span> <span class="o">=</span> <span class="n">old_seq_num</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="o">++*</span><span class="n">newest_inserted_seq_num_</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">while</span> <span class="p">(</span><span class="n">AheadOf</span><span class="p">(</span><span class="n">seq_num</span><span class="p">,</span> <span class="o">*</span><span class="n">newest_inserted_seq_num_</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">missing_packets_</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="o">*</span><span class="n">newest_inserted_seq_num_</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="o">++*</span><span class="n">newest_inserted_seq_num_</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">missing_packets_</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">seq_num</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>这里的<code>UpdateMissingPackets</code>主要是利用<code>missing_packets_</code>来维护丢包缓存。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">PacketBuffer</span><span class="o">::</span><span class="n">Packet</span><span class="o">&gt;&gt;</span> <span class="n">PacketBuffer</span><span class="o">::</span><span class="n">FindFrames</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="kt">uint16_t</span> <span class="n">seq_num</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">PacketBuffer</span><span class="o">::</span><span class="n">Packet</span><span class="o">&gt;&gt;</span> <span class="n">found_frames</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">auto</span> <span class="n">start</span> <span class="o">=</span> <span class="n">seq_num</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">for</span> <span class="p">(</span><span class="n">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">buffer_</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">received_padding_</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">seq_num</span><span class="p">)</span> <span class="o">!=</span> <span class="n">received_padding_</span><span class="p">.</span><span class="n">end</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">seq_num</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="k">continue</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">PotentialNewFrame</span><span class="p">(</span><span class="n">seq_num</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">size_t</span> <span class="n">index</span> <span class="o">=</span> <span class="n">seq_num</span> <span class="o">%</span> <span class="n">buffer_</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="n">buffer_</span><span class="p">[</span><span class="n">index</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">continuous</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// If all packets of the frame is continuous, find the first packet of the
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// frame and add all packets of the frame to the returned packets.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">buffer_</span><span class="p">[</span><span class="n">index</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">is_last_packet_in_frame</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="kt">uint16_t</span> <span class="n">start_seq_num</span> <span class="o">=</span> <span class="n">seq_num</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      <span class="c1">// Find the start index by searching backward until the packet with
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="c1">// the `frame_begin` flag is set.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="kt">int</span> <span class="n">start_index</span> <span class="o">=</span> <span class="n">index</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="n">size_t</span> <span class="n">tested_packets</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="kt">int64_t</span> <span class="n">frame_timestamp</span> <span class="o">=</span> <span class="n">buffer_</span><span class="p">[</span><span class="n">start_index</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">timestamp</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      <span class="c1">// Identify H.264 keyframes by means of SPS, PPS, and IDR.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="kt">bool</span> <span class="n">is_generic</span> <span class="o">=</span> <span class="n">buffer_</span><span class="p">[</span><span class="n">start_index</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">video_header</span><span class="p">.</span><span class="n">generic</span><span class="p">.</span><span class="n">has_value</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">      <span class="kt">bool</span> <span class="n">is_h264_descriptor</span> <span class="o">=</span>
</span></span><span class="line"><span class="cl">          <span class="p">(</span><span class="n">buffer_</span><span class="p">[</span><span class="n">start_index</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">codec</span><span class="p">()</span> <span class="o">==</span> <span class="n">kVideoCodecH264</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">is_generic</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="kt">bool</span> <span class="n">has_h264_sps</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="kt">bool</span> <span class="n">has_h264_pps</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="kt">bool</span> <span class="n">has_h264_idr</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="kt">bool</span> <span class="n">is_h264_keyframe</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="kt">int</span> <span class="n">idr_width</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="kt">int</span> <span class="n">idr_height</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="kt">bool</span> <span class="n">full_frame_found</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="k">while</span> <span class="p">(</span><span class="nb">true</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="o">++</span><span class="n">tested_packets</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">		<span class="c1">// 如果是VPX，并且找到了frame_begin标识的第一个包，一帧完整
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">is_h264_descriptor</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">          <span class="k">if</span> <span class="p">(</span><span class="n">buffer_</span><span class="p">[</span><span class="n">start_index</span><span class="p">]</span> <span class="o">==</span> <span class="k">nullptr</span> <span class="o">||</span>
</span></span><span class="line"><span class="cl">              <span class="n">buffer_</span><span class="p">[</span><span class="n">start_index</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">is_first_packet_in_frame</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">full_frame_found</span> <span class="o">=</span> <span class="n">buffer_</span><span class="p">[</span><span class="n">start_index</span><span class="p">]</span> <span class="o">!=</span> <span class="k">nullptr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">          <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">is_h264_descriptor</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">          <span class="k">const</span> <span class="k">auto</span><span class="o">*</span> <span class="n">h264_header</span> <span class="o">=</span> <span class="n">absl</span><span class="o">::</span><span class="n">get_if</span><span class="o">&lt;</span><span class="n">RTPVideoHeaderH264</span><span class="o">&gt;</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">              <span class="o">&amp;</span><span class="n">buffer_</span><span class="p">[</span><span class="n">start_index</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">video_header</span><span class="p">.</span><span class="n">video_type_header</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">          <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">h264_header</span> <span class="o">||</span> <span class="n">h264_header</span><span class="o">-&gt;</span><span class="n">nalus_length</span> <span class="o">&gt;=</span> <span class="n">kMaxNalusPerPacket</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span> <span class="n">found_frames</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">          <span class="k">for</span> <span class="p">(</span><span class="n">size_t</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">h264_header</span><span class="o">-&gt;</span><span class="n">nalus_length</span><span class="p">;</span> <span class="o">++</span><span class="n">j</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="p">(</span><span class="n">h264_header</span><span class="o">-&gt;</span><span class="n">nalus</span><span class="p">[</span><span class="n">j</span><span class="p">].</span><span class="n">type</span> <span class="o">==</span> <span class="n">H264</span><span class="o">::</span><span class="n">NaluType</span><span class="o">::</span><span class="n">kSps</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">              <span class="n">has_h264_sps</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span> <span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="n">h264_header</span><span class="o">-&gt;</span><span class="n">nalus</span><span class="p">[</span><span class="n">j</span><span class="p">].</span><span class="n">type</span> <span class="o">==</span> <span class="n">H264</span><span class="o">::</span><span class="n">NaluType</span><span class="o">::</span><span class="n">kPps</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">              <span class="n">has_h264_pps</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span> <span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="n">h264_header</span><span class="o">-&gt;</span><span class="n">nalus</span><span class="p">[</span><span class="n">j</span><span class="p">].</span><span class="n">type</span> <span class="o">==</span> <span class="n">H264</span><span class="o">::</span><span class="n">NaluType</span><span class="o">::</span><span class="n">kIdr</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">              <span class="n">has_h264_idr</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">          <span class="p">}</span>
</span></span><span class="line"><span class="cl">          <span class="k">if</span> <span class="p">((</span><span class="n">sps_pps_idr_is_h264_keyframe_</span> <span class="o">&amp;&amp;</span> <span class="n">has_h264_idr</span> <span class="o">&amp;&amp;</span> <span class="n">has_h264_sps</span> <span class="o">&amp;&amp;</span>
</span></span><span class="line"><span class="cl">               <span class="n">has_h264_pps</span><span class="p">)</span> <span class="o">||</span>
</span></span><span class="line"><span class="cl">              <span class="p">(</span><span class="o">!</span><span class="n">sps_pps_idr_is_h264_keyframe_</span> <span class="o">&amp;&amp;</span> <span class="n">has_h264_idr</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">is_h264_keyframe</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// Store the resolution of key frame which is the packet with
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// smallest index and valid resolution; typically its IDR or SPS
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// packet; there may be packet preceeding this packet, IDR&#39;s
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// resolution will be applied to them.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="k">if</span> <span class="p">(</span><span class="n">buffer_</span><span class="p">[</span><span class="n">start_index</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">width</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span>
</span></span><span class="line"><span class="cl">                <span class="n">buffer_</span><span class="p">[</span><span class="n">start_index</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">height</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">              <span class="n">idr_width</span> <span class="o">=</span> <span class="n">buffer_</span><span class="p">[</span><span class="n">start_index</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">width</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">              <span class="n">idr_height</span> <span class="o">=</span> <span class="n">buffer_</span><span class="p">[</span><span class="n">start_index</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">height</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">          <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">tested_packets</span> <span class="o">==</span> <span class="n">buffer_</span><span class="p">.</span><span class="n">size</span><span class="p">())</span>
</span></span><span class="line"><span class="cl">          <span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="n">start_index</span> <span class="o">=</span> <span class="n">start_index</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">?</span> <span class="n">start_index</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">:</span> <span class="n">buffer_</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// In the case of H264 we don&#39;t have a frame_begin bit (yes,
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// `frame_begin` might be set to true but that is a lie). So instead
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// we traverese backwards as long as we have a previous packet and
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// the timestamp of that packet is the same as this one. This may cause
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// the PacketBuffer to hand out incomplete frames.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// See: https://bugs.chromium.org/p/webrtc/issues/detail?id=7106
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">if</span> <span class="p">(</span><span class="n">is_h264_descriptor</span> <span class="o">&amp;&amp;</span>
</span></span><span class="line"><span class="cl">            <span class="p">(</span><span class="n">buffer_</span><span class="p">[</span><span class="n">start_index</span><span class="p">]</span> <span class="o">==</span> <span class="k">nullptr</span> <span class="o">||</span>
</span></span><span class="line"><span class="cl">             <span class="n">buffer_</span><span class="p">[</span><span class="n">start_index</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">timestamp</span> <span class="o">!=</span> <span class="n">frame_timestamp</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">          <span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="o">--</span><span class="n">start_seq_num</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      <span class="k">if</span> <span class="p">(</span><span class="n">is_h264_descriptor</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// Warn if this is an unsafe frame.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">if</span> <span class="p">(</span><span class="n">has_h264_idr</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="o">!</span><span class="n">has_h264_sps</span> <span class="o">||</span> <span class="o">!</span><span class="n">has_h264_pps</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">          <span class="n">RTC_LOG</span><span class="p">(</span><span class="n">LS_WARNING</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">              <span class="o">&lt;&lt;</span> <span class="s">&#34;Received H.264-IDR frame &#34;</span>
</span></span><span class="line"><span class="cl">                 <span class="s">&#34;(SPS: &#34;</span>
</span></span><span class="line"><span class="cl">              <span class="o">&lt;&lt;</span> <span class="n">has_h264_sps</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;, PPS: &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">has_h264_pps</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;). Treating as &#34;</span>
</span></span><span class="line"><span class="cl">              <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">sps_pps_idr_is_h264_keyframe_</span> <span class="o">?</span> <span class="s">&#34;delta&#34;</span> <span class="o">:</span> <span class="s">&#34;key&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">              <span class="o">&lt;&lt;</span> <span class="s">&#34; frame since WebRTC-SpsPpsIdrIsH264Keyframe is &#34;</span>
</span></span><span class="line"><span class="cl">              <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">sps_pps_idr_is_h264_keyframe_</span> <span class="o">?</span> <span class="s">&#34;enabled.&#34;</span> <span class="o">:</span> <span class="s">&#34;disabled&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// Now that we have decided whether to treat this frame as a key frame
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// or delta frame in the frame buffer, we update the field that
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// determines if the RtpFrameObject is a key frame or delta frame.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">const</span> <span class="n">size_t</span> <span class="n">first_packet_index</span> <span class="o">=</span> <span class="n">start_seq_num</span> <span class="o">%</span> <span class="n">buffer_</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">is_h264_keyframe</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">          <span class="n">buffer_</span><span class="p">[</span><span class="n">first_packet_index</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">video_header</span><span class="p">.</span><span class="n">frame_type</span> <span class="o">=</span>
</span></span><span class="line"><span class="cl">              <span class="n">VideoFrameType</span><span class="o">::</span><span class="n">kVideoFrameKey</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">          <span class="k">if</span> <span class="p">(</span><span class="n">idr_width</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">idr_height</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// IDR frame was finalized and we have the correct resolution for
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// IDR; update first packet to have same resolution as IDR.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="n">buffer_</span><span class="p">[</span><span class="n">first_packet_index</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">video_header</span><span class="p">.</span><span class="n">width</span> <span class="o">=</span> <span class="n">idr_width</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="n">buffer_</span><span class="p">[</span><span class="n">first_packet_index</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">video_header</span><span class="p">.</span><span class="n">height</span> <span class="o">=</span> <span class="n">idr_height</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">          <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">          <span class="n">buffer_</span><span class="p">[</span><span class="n">first_packet_index</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">video_header</span><span class="p">.</span><span class="n">frame_type</span> <span class="o">=</span>
</span></span><span class="line"><span class="cl">              <span class="n">VideoFrameType</span><span class="o">::</span><span class="n">kVideoFrameDelta</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// If this is not a keyframe, make sure there are no gaps in the packet
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// sequence numbers up until this point.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">is_h264_keyframe</span> <span class="o">&amp;&amp;</span> <span class="n">missing_packets_</span><span class="p">.</span><span class="n">upper_bound</span><span class="p">(</span><span class="n">start_seq_num</span><span class="p">)</span> <span class="o">!=</span>
</span></span><span class="line"><span class="cl">                                     <span class="n">missing_packets_</span><span class="p">.</span><span class="n">begin</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">          <span class="k">return</span> <span class="n">found_frames</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      <span class="k">if</span> <span class="p">(</span><span class="n">is_h264_descriptor</span> <span class="o">||</span> <span class="n">full_frame_found</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">const</span> <span class="kt">uint16_t</span> <span class="n">end_seq_num</span> <span class="o">=</span> <span class="n">seq_num</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// Use uint16_t type to handle sequence number wrap around case.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="kt">uint16_t</span> <span class="n">num_packets</span> <span class="o">=</span> <span class="n">end_seq_num</span> <span class="o">-</span> <span class="n">start_seq_num</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">found_frames</span><span class="p">.</span><span class="n">reserve</span><span class="p">(</span><span class="n">found_frames</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">+</span> <span class="n">num_packets</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="p">(</span><span class="kt">uint16_t</span> <span class="n">i</span> <span class="o">=</span> <span class="n">start_seq_num</span><span class="p">;</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">end_seq_num</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">          <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Packet</span><span class="o">&gt;&amp;</span> <span class="n">packet</span> <span class="o">=</span> <span class="n">buffer_</span><span class="p">[</span><span class="n">i</span> <span class="o">%</span> <span class="n">buffer_</span><span class="p">.</span><span class="n">size</span><span class="p">()];</span>
</span></span><span class="line"><span class="cl">          <span class="n">RTC_DCHECK</span><span class="p">(</span><span class="n">packet</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">          <span class="n">RTC_DCHECK_EQ</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">packet</span><span class="o">-&gt;</span><span class="n">seq_num</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">          <span class="c1">// Ensure frame boundary flags are properly set.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>          <span class="n">packet</span><span class="o">-&gt;</span><span class="n">video_header</span><span class="p">.</span><span class="n">is_first_packet_in_frame</span> <span class="o">=</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">start_seq_num</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">          <span class="n">packet</span><span class="o">-&gt;</span><span class="n">video_header</span><span class="p">.</span><span class="n">is_last_packet_in_frame</span> <span class="o">=</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">seq_num</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">          <span class="n">found_frames</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">packet</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="n">missing_packets_</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">missing_packets_</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span>
</span></span><span class="line"><span class="cl">                               <span class="n">missing_packets_</span><span class="p">.</span><span class="n">upper_bound</span><span class="p">(</span><span class="n">seq_num</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">        <span class="n">received_padding_</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">received_padding_</span><span class="p">.</span><span class="n">lower_bound</span><span class="p">(</span><span class="n">start</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">                                <span class="n">received_padding_</span><span class="p">.</span><span class="n">upper_bound</span><span class="p">(</span><span class="n">seq_num</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="o">++</span><span class="n">seq_num</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="n">found_frames</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p><code>FindFrames</code>的主要工作是检测帧的完整性，具体的实现方式是遍历排序缓存中连续的包，来检查一帧的边界，并且对于 VPX 和 H264 的处理做了区分。对于 VPX，通过检测 frame_begin 和 frame_end 这两个包来确定收到了一个完整的帧，而对于 H264 则通过从 frame_end 标识的一帧最后一个包向前追溯，直到找到一个时间戳不一样的断层，认为找到了完整的一个 H264 的帧。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">RtpVideoStreamReceiver2</span><span class="o">::</span><span class="n">OnInsertedPacket</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="n">video_coding</span><span class="o">::</span><span class="n">PacketBuffer</span><span class="o">::</span><span class="n">InsertResult</span> <span class="n">result</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">RTC_DCHECK_RUN_ON</span><span class="p">(</span><span class="o">&amp;</span><span class="n">packet_sequence_checker_</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">RTC_DCHECK_RUN_ON</span><span class="p">(</span><span class="o">&amp;</span><span class="n">worker_task_checker_</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">video_coding</span><span class="o">::</span><span class="n">PacketBuffer</span><span class="o">::</span><span class="n">Packet</span><span class="o">*</span> <span class="n">first_packet</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="kt">int</span> <span class="n">max_nack_count</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="kt">int64_t</span> <span class="n">min_recv_time</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="kt">int64_t</span> <span class="n">max_recv_time</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">rtc</span><span class="o">::</span><span class="n">ArrayView</span><span class="o">&lt;</span><span class="k">const</span> <span class="kt">uint8_t</span><span class="o">&gt;&gt;</span> <span class="n">payloads</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">RtpPacketInfos</span><span class="o">::</span><span class="n">vector_type</span> <span class="n">packet_infos</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="kt">bool</span> <span class="n">frame_boundary</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">for</span> <span class="p">(</span><span class="k">auto</span><span class="o">&amp;</span> <span class="nl">packet</span> <span class="p">:</span> <span class="n">result</span><span class="p">.</span><span class="n">packets</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// PacketBuffer promisses frame boundaries are correctly set on each
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// packet. Document that assumption with the DCHECKs.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">RTC_DCHECK_EQ</span><span class="p">(</span><span class="n">frame_boundary</span><span class="p">,</span> <span class="n">packet</span><span class="o">-&gt;</span><span class="n">is_first_packet_in_frame</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int64_t</span> <span class="n">unwrapped_rtp_seq_num</span> <span class="o">=</span>
</span></span><span class="line"><span class="cl">        <span class="n">rtp_seq_num_unwrapper_</span><span class="p">.</span><span class="n">Unwrap</span><span class="p">(</span><span class="n">packet</span><span class="o">-&gt;</span><span class="n">seq_num</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">RTC_DCHECK_GT</span><span class="p">(</span><span class="n">packet_infos_</span><span class="p">.</span><span class="n">count</span><span class="p">(</span><span class="n">unwrapped_rtp_seq_num</span><span class="p">),</span> <span class="mi">0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">RtpPacketInfo</span><span class="o">&amp;</span> <span class="n">packet_info</span> <span class="o">=</span> <span class="n">packet_infos_</span><span class="p">[</span><span class="n">unwrapped_rtp_seq_num</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">packet</span><span class="o">-&gt;</span><span class="n">is_first_packet_in_frame</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">first_packet</span> <span class="o">=</span> <span class="n">packet</span><span class="p">.</span><span class="n">get</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">      <span class="n">max_nack_count</span> <span class="o">=</span> <span class="n">packet</span><span class="o">-&gt;</span><span class="n">times_nacked</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="n">min_recv_time</span> <span class="o">=</span> <span class="n">packet_info</span><span class="p">.</span><span class="n">receive_time</span><span class="p">().</span><span class="n">ms</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">      <span class="n">max_recv_time</span> <span class="o">=</span> <span class="n">packet_info</span><span class="p">.</span><span class="n">receive_time</span><span class="p">().</span><span class="n">ms</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">max_nack_count</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">max</span><span class="p">(</span><span class="n">max_nack_count</span><span class="p">,</span> <span class="n">packet</span><span class="o">-&gt;</span><span class="n">times_nacked</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="n">min_recv_time</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">min</span><span class="p">(</span><span class="n">min_recv_time</span><span class="p">,</span> <span class="n">packet_info</span><span class="p">.</span><span class="n">receive_time</span><span class="p">().</span><span class="n">ms</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">      <span class="n">max_recv_time</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">max</span><span class="p">(</span><span class="n">max_recv_time</span><span class="p">,</span> <span class="n">packet_info</span><span class="p">.</span><span class="n">receive_time</span><span class="p">().</span><span class="n">ms</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="n">payloads</span><span class="p">.</span><span class="n">emplace_back</span><span class="p">(</span><span class="n">packet</span><span class="o">-&gt;</span><span class="n">video_payload</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">packet_infos</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">packet_info</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">frame_boundary</span> <span class="o">=</span> <span class="n">packet</span><span class="o">-&gt;</span><span class="n">is_last_packet_in_frame</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">packet</span><span class="o">-&gt;</span><span class="n">is_last_packet_in_frame</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">auto</span> <span class="n">depacketizer_it</span> <span class="o">=</span> <span class="n">payload_type_map_</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">first_packet</span><span class="o">-&gt;</span><span class="n">payload_type</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="n">RTC_CHECK</span><span class="p">(</span><span class="n">depacketizer_it</span> <span class="o">!=</span> <span class="n">payload_type_map_</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">      <span class="n">RTC_CHECK</span><span class="p">(</span><span class="n">depacketizer_it</span><span class="o">-&gt;</span><span class="n">second</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      <span class="n">rtc</span><span class="o">::</span><span class="n">scoped_refptr</span><span class="o">&lt;</span><span class="n">EncodedImageBuffer</span><span class="o">&gt;</span> <span class="n">bitstream</span> <span class="o">=</span>
</span></span><span class="line"><span class="cl">          <span class="n">depacketizer_it</span><span class="o">-&gt;</span><span class="n">second</span><span class="o">-&gt;</span><span class="n">AssembleFrame</span><span class="p">(</span><span class="n">payloads</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bitstream</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// Failed to assemble a frame. Discard and continue.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">continue</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      <span class="k">const</span> <span class="n">video_coding</span><span class="o">::</span><span class="n">PacketBuffer</span><span class="o">::</span><span class="n">Packet</span><span class="o">&amp;</span> <span class="n">last_packet</span> <span class="o">=</span> <span class="o">*</span><span class="n">packet</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="n">OnAssembledFrame</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">RtpFrameObject</span><span class="o">&gt;</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">          <span class="n">first_packet</span><span class="o">-&gt;</span><span class="n">seq_num</span><span class="p">,</span>                             <span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>          <span class="n">last_packet</span><span class="p">.</span><span class="n">seq_num</span><span class="p">,</span>                               <span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>          <span class="n">last_packet</span><span class="p">.</span><span class="n">marker_bit</span><span class="p">,</span>                            <span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>          <span class="n">max_nack_count</span><span class="p">,</span>                                    <span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>          <span class="n">min_recv_time</span><span class="p">,</span>                                     <span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>          <span class="n">max_recv_time</span><span class="p">,</span>                                     <span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>          <span class="n">first_packet</span><span class="o">-&gt;</span><span class="n">timestamp</span><span class="p">,</span>                           <span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>          <span class="n">ntp_estimator_</span><span class="p">.</span><span class="n">Estimate</span><span class="p">(</span><span class="n">first_packet</span><span class="o">-&gt;</span><span class="n">timestamp</span><span class="p">),</span>  <span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>          <span class="n">last_packet</span><span class="p">.</span><span class="n">video_header</span><span class="p">.</span><span class="n">video_timing</span><span class="p">,</span>             <span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>          <span class="n">first_packet</span><span class="o">-&gt;</span><span class="n">payload_type</span><span class="p">,</span>                        <span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>          <span class="n">first_packet</span><span class="o">-&gt;</span><span class="n">codec</span><span class="p">(),</span>                             <span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>          <span class="n">last_packet</span><span class="p">.</span><span class="n">video_header</span><span class="p">.</span><span class="n">rotation</span><span class="p">,</span>                 <span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>          <span class="n">last_packet</span><span class="p">.</span><span class="n">video_header</span><span class="p">.</span><span class="n">content_type</span><span class="p">,</span>             <span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>          <span class="n">first_packet</span><span class="o">-&gt;</span><span class="n">video_header</span><span class="p">,</span>                        <span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>          <span class="n">last_packet</span><span class="p">.</span><span class="n">video_header</span><span class="p">.</span><span class="n">color_space</span><span class="p">,</span>              <span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>          <span class="n">RtpPacketInfos</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">packet_infos</span><span class="p">)),</span>           <span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>          <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">bitstream</span><span class="p">)));</span>
</span></span><span class="line"><span class="cl">      <span class="n">payloads</span><span class="p">.</span><span class="n">clear</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">      <span class="n">packet_infos</span><span class="p">.</span><span class="n">clear</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="n">RTC_DCHECK</span><span class="p">(</span><span class="n">frame_boundary</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="n">result</span><span class="p">.</span><span class="n">buffer_cleared</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">last_received_rtp_system_time_</span><span class="p">.</span><span class="n">reset</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="n">last_received_keyframe_rtp_system_time_</span><span class="p">.</span><span class="n">reset</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="n">last_received_keyframe_rtp_timestamp_</span><span class="p">.</span><span class="n">reset</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="n">packet_infos_</span><span class="p">.</span><span class="n">clear</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="n">RequestKeyFrame</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>在<code>OnInsertedPacket</code>中的主要逻辑就是缓存解析好的 packet，在遍历到当前帧的最后一个包之后调用<code>OnAssembledFrame</code>进行组帧。至此，rtp 包的排序和组帧的工作结束。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">RtpVideoStreamReceiver2</span><span class="o">::</span><span class="n">OnAssembledFrame</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">RtpFrameObject</span><span class="o">&gt;</span> <span class="n">frame</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">RTC_DCHECK_RUN_ON</span><span class="p">(</span><span class="o">&amp;</span><span class="n">packet_sequence_checker_</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">RTC_DCHECK</span><span class="p">(</span><span class="n">frame</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">const</span> <span class="n">absl</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="n">RTPVideoHeader</span><span class="o">::</span><span class="n">GenericDescriptorInfo</span><span class="o">&gt;&amp;</span> <span class="n">descriptor</span> <span class="o">=</span>
</span></span><span class="line"><span class="cl">      <span class="n">frame</span><span class="o">-&gt;</span><span class="n">GetRtpVideoHeader</span><span class="p">().</span><span class="n">generic</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="n">loss_notification_controller_</span> <span class="o">&amp;&amp;</span> <span class="n">descriptor</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">loss_notification_controller_</span><span class="o">-&gt;</span><span class="n">OnAssembledFrame</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">        <span class="n">frame</span><span class="o">-&gt;</span><span class="n">first_seq_num</span><span class="p">(),</span> <span class="n">descriptor</span><span class="o">-&gt;</span><span class="n">frame_id</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">        <span class="n">absl</span><span class="o">::</span><span class="n">c_linear_search</span><span class="p">(</span><span class="n">descriptor</span><span class="o">-&gt;</span><span class="n">decode_target_indications</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                              <span class="n">DecodeTargetIndication</span><span class="o">::</span><span class="n">kDiscardable</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">        <span class="n">descriptor</span><span class="o">-&gt;</span><span class="n">dependencies</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// If frames arrive before a key frame, they would not be decodable.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// In that case, request a key frame ASAP.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">has_received_frame_</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">frame</span><span class="o">-&gt;</span><span class="n">FrameType</span><span class="p">()</span> <span class="o">!=</span> <span class="n">VideoFrameType</span><span class="o">::</span><span class="n">kVideoFrameKey</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="c1">// `loss_notification_controller_`, if present, would have already
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="c1">// requested a key frame when the first packet for the non-key frame
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="c1">// had arrived, so no need to replicate the request.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">loss_notification_controller_</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">RequestKeyFrame</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="n">has_received_frame_</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// Reset `reference_finder_` if `frame` is new and the codec have changed.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">if</span> <span class="p">(</span><span class="n">current_codec_</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">bool</span> <span class="n">frame_is_newer</span> <span class="o">=</span>
</span></span><span class="line"><span class="cl">        <span class="n">AheadOf</span><span class="p">(</span><span class="n">frame</span><span class="o">-&gt;</span><span class="n">RtpTimestamp</span><span class="p">(),</span> <span class="n">last_assembled_frame_rtp_timestamp_</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">frame</span><span class="o">-&gt;</span><span class="n">codec_type</span><span class="p">()</span> <span class="o">!=</span> <span class="n">current_codec_</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">if</span> <span class="p">(</span><span class="n">frame_is_newer</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// When we reset the `reference_finder_` we don&#39;t want new picture ids
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// to overlap with old picture ids. To ensure that doesn&#39;t happen we
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// start from the `last_completed_picture_id_` and add an offset in case
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// of reordering.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">reference_finder_</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">RtpFrameReferenceFinder</span><span class="o">&gt;</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">            <span class="n">last_completed_picture_id_</span> <span class="o">+</span> <span class="n">std</span><span class="o">::</span><span class="n">numeric_limits</span><span class="o">&lt;</span><span class="kt">uint16_t</span><span class="o">&gt;::</span><span class="n">max</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">        <span class="n">current_codec_</span> <span class="o">=</span> <span class="n">frame</span><span class="o">-&gt;</span><span class="n">codec_type</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// Old frame from before the codec switch, discard it.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">return</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">frame_is_newer</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">last_assembled_frame_rtp_timestamp_</span> <span class="o">=</span> <span class="n">frame</span><span class="o">-&gt;</span><span class="n">RtpTimestamp</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">current_codec_</span> <span class="o">=</span> <span class="n">frame</span><span class="o">-&gt;</span><span class="n">codec_type</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="n">last_assembled_frame_rtp_timestamp_</span> <span class="o">=</span> <span class="n">frame</span><span class="o">-&gt;</span><span class="n">RtpTimestamp</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="n">buffered_frame_decryptor_</span> <span class="o">!=</span> <span class="k">nullptr</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">buffered_frame_decryptor_</span><span class="o">-&gt;</span><span class="n">ManageEncryptedFrame</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">frame</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span> <span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="n">frame_transformer_delegate_</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">frame_transformer_delegate_</span><span class="o">-&gt;</span><span class="n">TransformFrame</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">frame</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">OnCompleteFrames</span><span class="p">(</span><span class="n">reference_finder_</span><span class="o">-&gt;</span><span class="n">ManageFrame</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">frame</span><span class="p">)));</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>在<code>OnAssembledFrame</code>中则通过调用<code>RtpFrameReferenceFinder</code>的<code>ManageFrame</code>来寻找一个帧解码时所依赖的帧。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">RtpFrameReferenceFinder</span><span class="o">::</span><span class="n">ReturnVector</span> <span class="n">RtpFrameReferenceFinder</span><span class="o">::</span><span class="n">ManageFrame</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">RtpFrameObject</span><span class="o">&gt;</span> <span class="n">frame</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// If we have cleared past this frame, drop it.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">if</span> <span class="p">(</span><span class="n">cleared_to_seq_num_</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span> <span class="o">&amp;&amp;</span>
</span></span><span class="line"><span class="cl">      <span class="n">AheadOf</span><span class="o">&lt;</span><span class="kt">uint16_t</span><span class="o">&gt;</span><span class="p">(</span><span class="n">cleared_to_seq_num_</span><span class="p">,</span> <span class="n">frame</span><span class="o">-&gt;</span><span class="n">first_seq_num</span><span class="p">()))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="p">{};</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">auto</span> <span class="n">frames</span> <span class="o">=</span> <span class="n">impl_</span><span class="o">-&gt;</span><span class="n">ManageFrame</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">frame</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">  <span class="n">AddPictureIdOffset</span><span class="p">(</span><span class="n">frames</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="n">frames</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>这里的<code>impl_</code>是<code>RtpFrameReferenceFinder</code>代码逻辑的实现类的实例，其<code>ManageFrame</code>函数是寻找依赖帧的核心逻辑。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">RtpFrameReferenceFinder</span><span class="o">::</span><span class="n">ReturnVector</span> <span class="n">RtpFrameReferenceFinderImpl</span><span class="o">::</span><span class="n">ManageFrame</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">RtpFrameObject</span><span class="o">&gt;</span> <span class="n">frame</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">const</span> <span class="n">RTPVideoHeader</span><span class="o">&amp;</span> <span class="n">video_header</span> <span class="o">=</span> <span class="n">frame</span><span class="o">-&gt;</span><span class="n">GetRtpVideoHeader</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="n">video_header</span><span class="p">.</span><span class="n">generic</span><span class="p">.</span><span class="n">has_value</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">GetRefFinderAs</span><span class="o">&lt;</span><span class="n">RtpGenericFrameRefFinder</span><span class="o">&gt;</span><span class="p">().</span><span class="n">ManageFrame</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">        <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">frame</span><span class="p">),</span> <span class="o">*</span><span class="n">video_header</span><span class="p">.</span><span class="n">generic</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">switch</span> <span class="p">(</span><span class="n">frame</span><span class="o">-&gt;</span><span class="n">codec_type</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">case</span> <span class="nl">kVideoCodecVP8</span><span class="p">:</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">const</span> <span class="n">RTPVideoHeaderVP8</span><span class="o">&amp;</span> <span class="n">vp8_header</span> <span class="o">=</span>
</span></span><span class="line"><span class="cl">          <span class="n">absl</span><span class="o">::</span><span class="n">get</span><span class="o">&lt;</span><span class="n">RTPVideoHeaderVP8</span><span class="o">&gt;</span><span class="p">(</span><span class="n">video_header</span><span class="p">.</span><span class="n">video_type_header</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      <span class="k">if</span> <span class="p">(</span><span class="n">vp8_header</span><span class="p">.</span><span class="n">temporalIdx</span> <span class="o">==</span> <span class="n">kNoTemporalIdx</span> <span class="o">||</span>
</span></span><span class="line"><span class="cl">          <span class="n">vp8_header</span><span class="p">.</span><span class="n">tl0PicIdx</span> <span class="o">==</span> <span class="n">kNoTl0PicIdx</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">vp8_header</span><span class="p">.</span><span class="n">pictureId</span> <span class="o">==</span> <span class="n">kNoPictureId</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">          <span class="k">return</span> <span class="n">GetRefFinderAs</span><span class="o">&lt;</span><span class="n">RtpSeqNumOnlyRefFinder</span><span class="o">&gt;</span><span class="p">().</span><span class="n">ManageFrame</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">              <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">frame</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">GetRefFinderAs</span><span class="o">&lt;</span><span class="n">RtpFrameIdOnlyRefFinder</span><span class="o">&gt;</span><span class="p">().</span><span class="n">ManageFrame</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">            <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">frame</span><span class="p">),</span> <span class="n">vp8_header</span><span class="p">.</span><span class="n">pictureId</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      <span class="k">return</span> <span class="n">GetRefFinderAs</span><span class="o">&lt;</span><span class="n">RtpVp8RefFinder</span><span class="o">&gt;</span><span class="p">().</span><span class="n">ManageFrame</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">frame</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">case</span> <span class="nl">kVideoCodecVP9</span><span class="p">:</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">const</span> <span class="n">RTPVideoHeaderVP9</span><span class="o">&amp;</span> <span class="n">vp9_header</span> <span class="o">=</span>
</span></span><span class="line"><span class="cl">          <span class="n">absl</span><span class="o">::</span><span class="n">get</span><span class="o">&lt;</span><span class="n">RTPVideoHeaderVP9</span><span class="o">&gt;</span><span class="p">(</span><span class="n">video_header</span><span class="p">.</span><span class="n">video_type_header</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      <span class="k">if</span> <span class="p">(</span><span class="n">vp9_header</span><span class="p">.</span><span class="n">temporal_idx</span> <span class="o">==</span> <span class="n">kNoTemporalIdx</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">vp9_header</span><span class="p">.</span><span class="n">picture_id</span> <span class="o">==</span> <span class="n">kNoPictureId</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">          <span class="k">return</span> <span class="n">GetRefFinderAs</span><span class="o">&lt;</span><span class="n">RtpSeqNumOnlyRefFinder</span><span class="o">&gt;</span><span class="p">().</span><span class="n">ManageFrame</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">              <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">frame</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">GetRefFinderAs</span><span class="o">&lt;</span><span class="n">RtpFrameIdOnlyRefFinder</span><span class="o">&gt;</span><span class="p">().</span><span class="n">ManageFrame</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">            <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">frame</span><span class="p">),</span> <span class="n">vp9_header</span><span class="p">.</span><span class="n">picture_id</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      <span class="k">return</span> <span class="n">GetRefFinderAs</span><span class="o">&lt;</span><span class="n">RtpVp9RefFinder</span><span class="o">&gt;</span><span class="p">().</span><span class="n">ManageFrame</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">frame</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">case</span> <span class="nl">kVideoCodecGeneric</span><span class="p">:</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">if</span> <span class="p">(</span><span class="k">auto</span><span class="o">*</span> <span class="n">generic_header</span> <span class="o">=</span> <span class="n">absl</span><span class="o">::</span><span class="n">get_if</span><span class="o">&lt;</span><span class="n">RTPVideoHeaderLegacyGeneric</span><span class="o">&gt;</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">              <span class="o">&amp;</span><span class="n">video_header</span><span class="p">.</span><span class="n">video_type_header</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">GetRefFinderAs</span><span class="o">&lt;</span><span class="n">RtpFrameIdOnlyRefFinder</span><span class="o">&gt;</span><span class="p">().</span><span class="n">ManageFrame</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">            <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">frame</span><span class="p">),</span> <span class="n">generic_header</span><span class="o">-&gt;</span><span class="n">picture_id</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      <span class="k">return</span> <span class="n">GetRefFinderAs</span><span class="o">&lt;</span><span class="n">RtpSeqNumOnlyRefFinder</span><span class="o">&gt;</span><span class="p">().</span><span class="n">ManageFrame</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">          <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">frame</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">default</span><span class="o">:</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">return</span> <span class="n">GetRefFinderAs</span><span class="o">&lt;</span><span class="n">RtpSeqNumOnlyRefFinder</span><span class="o">&gt;</span><span class="p">().</span><span class="n">ManageFrame</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">          <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">frame</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>在这个方法中主要是针对不同的编码类型做了分类处理，实际上完成寻找依赖帧工作的函数则交给了<code>RtpSeqNumOnlyRefFinder</code>的<code>ManageFrame</code>和<code>ManageFrameInternal</code>。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">RtpFrameReferenceFinder</span><span class="o">::</span><span class="n">ReturnVector</span> <span class="n">RtpSeqNumOnlyRefFinder</span><span class="o">::</span><span class="n">ManageFrame</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">RtpFrameObject</span><span class="o">&gt;</span> <span class="n">frame</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">FrameDecision</span> <span class="n">decision</span> <span class="o">=</span> <span class="n">ManageFrameInternal</span><span class="p">(</span><span class="n">frame</span><span class="p">.</span><span class="n">get</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">RtpFrameReferenceFinder</span><span class="o">::</span><span class="n">ReturnVector</span> <span class="n">res</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">switch</span> <span class="p">(</span><span class="n">decision</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">case</span> <span class="nl">kStash</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">      <span class="k">if</span> <span class="p">(</span><span class="n">stashed_frames_</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&gt;</span> <span class="n">kMaxStashedFrames</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="n">stashed_frames_</span><span class="p">.</span><span class="n">pop_back</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">      <span class="n">stashed_frames_</span><span class="p">.</span><span class="n">push_front</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">frame</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">      <span class="k">return</span> <span class="n">res</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">case</span> <span class="nl">kHandOff</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">      <span class="n">res</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">frame</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">      <span class="n">RetryStashedFrames</span><span class="p">(</span><span class="n">res</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="k">return</span> <span class="n">res</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">case</span> <span class="nl">kDrop</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">      <span class="k">return</span> <span class="n">res</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="n">res</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">RtpSeqNumOnlyRefFinder</span><span class="o">::</span><span class="n">FrameDecision</span>
</span></span><span class="line"><span class="cl"><span class="n">RtpSeqNumOnlyRefFinder</span><span class="o">::</span><span class="n">ManageFrameInternal</span><span class="p">(</span><span class="n">RtpFrameObject</span><span class="o">*</span> <span class="n">frame</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 如果是关键帧，插入GOP表，key是last_seq_num，初始value是{last_seq_num,last_seq_num}
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">if</span> <span class="p">(</span><span class="n">frame</span><span class="o">-&gt;</span><span class="n">frame_type</span><span class="p">()</span> <span class="o">==</span> <span class="n">VideoFrameType</span><span class="o">::</span><span class="n">kVideoFrameKey</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">last_seq_num_GOP_</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">make_pair</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">        <span class="n">frame</span><span class="o">-&gt;</span><span class="n">last_seq_num</span><span class="p">(),</span>
</span></span><span class="line"><span class="cl">        <span class="n">std</span><span class="o">::</span><span class="n">make_pair</span><span class="p">(</span><span class="n">frame</span><span class="o">-&gt;</span><span class="n">last_seq_num</span><span class="p">(),</span> <span class="n">frame</span><span class="o">-&gt;</span><span class="n">last_seq_num</span><span class="p">())));</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// We have received a frame but not yet a keyframe, stash this frame.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// 如果GOP表空，那么就不可能找到参考帧，先缓存
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">if</span> <span class="p">(</span><span class="n">last_seq_num_GOP_</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">kStash</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// Clean up info for old keyframes but make sure to keep info
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// for the last keyframe.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// 删除较老的关键帧(PID小于last_seq_num - 100), 但是至少保留一个
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">auto</span> <span class="n">clean_to</span> <span class="o">=</span> <span class="n">last_seq_num_gop_</span><span class="p">.</span><span class="n">lower_bound</span><span class="p">(</span><span class="n">frame</span><span class="o">-&gt;</span><span class="n">last_seq_num</span><span class="p">()</span> <span class="o">-</span> <span class="mi">100</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="n">it</span> <span class="o">=</span> <span class="n">last_seq_num_gop_</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">       <span class="n">it</span> <span class="o">!=</span> <span class="n">clean_to</span> <span class="o">&amp;&amp;</span> <span class="n">last_seq_num_gop_</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">;)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">it</span> <span class="o">=</span> <span class="n">last_seq_num_gop_</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">it</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// Find the last sequence number of the last frame for the keyframe
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// that this frame indirectly references.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// 在GOP表中搜索第一个比当前帧新的关键帧
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">auto</span> <span class="n">seq_num_it</span> <span class="o">=</span> <span class="n">last_seq_num_gop_</span><span class="p">.</span><span class="n">upper_bound</span><span class="p">(</span><span class="n">frame</span><span class="o">-&gt;</span><span class="n">last_seq_num</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 如果搜索到的关键帧是最老的，说明当前帧比最老的关键帧还老，无法设置参考帧，丢弃
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">if</span> <span class="p">(</span><span class="n">seq_num_it</span> <span class="o">==</span> <span class="n">last_seq_num_gop_</span><span class="p">.</span><span class="n">begin</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">RTC_LOG</span><span class="p">(</span><span class="n">LS_WARNING</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Generic frame with packet range [&#34;</span>
</span></span><span class="line"><span class="cl">                        <span class="o">&lt;&lt;</span> <span class="n">frame</span><span class="o">-&gt;</span><span class="n">first_seq_num</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;, &#34;</span>
</span></span><span class="line"><span class="cl">                        <span class="o">&lt;&lt;</span> <span class="n">frame</span><span class="o">-&gt;</span><span class="n">last_seq_num</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">                        <span class="o">&lt;&lt;</span> <span class="s">&#34;] has no GoP, dropping frame.&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">kDrop</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 如果搜索到的关键帧不是最老的，那么搜索到的关键帧的上一个关键帧所在的GOP里应该可以找到参考帧
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// 如果找不到关键帧，seq_num_it为end(), seq_num_it--则为最后一个关键帧
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">seq_num_it</span><span class="o">--</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// Make sure the packet sequence numbers are continuous, otherwise stash
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// this frame.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// 保证帧的连续，不连续则先缓存
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// 当前GOP的最新一个帧的最后一个包的序列号
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">uint16_t</span> <span class="n">last_picture_id_gop</span> <span class="o">=</span> <span class="n">seq_num_it</span><span class="o">-&gt;</span><span class="n">second</span><span class="p">.</span><span class="n">first</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 当前GOP的最新包的序列号，可能是last_picture_id_gop, 也可能是填充包
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">uint16_t</span> <span class="n">last_picture_id_with_padding_gop</span> <span class="o">=</span> <span class="n">seq_num_it</span><span class="o">-&gt;</span><span class="n">second</span><span class="p">.</span><span class="n">second</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// P帧的连续性检查
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">if</span> <span class="p">(</span><span class="n">frame</span><span class="o">-&gt;</span><span class="n">frame_type</span><span class="p">()</span> <span class="o">==</span> <span class="n">VideoFrameType</span><span class="o">::</span><span class="n">kVideoFrameDelta</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 获得P帧第一个包的上个包的序列号
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">uint16_t</span> <span class="n">prev_seq_num</span> <span class="o">=</span> <span class="n">frame</span><span class="o">-&gt;</span><span class="n">first_seq_num</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// 如果P帧第一个包的上个包的序列号与当前GOP的最新包的序列号不等，说明不连续，先缓存
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">prev_seq_num</span> <span class="o">!=</span> <span class="n">last_picture_id_with_padding_gop</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">      <span class="k">return</span> <span class="n">kStash</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 现在这个帧是连续的了
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">RTC_DCHECK</span><span class="p">(</span><span class="n">AheadOrAt</span><span class="p">(</span><span class="n">frame</span><span class="o">-&gt;</span><span class="n">last_seq_num</span><span class="p">(),</span> <span class="n">seq_num_it</span><span class="o">-&gt;</span><span class="n">first</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// Since keyframes can cause reordering we can&#39;t simply assign the
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// picture id according to some incrementing counter.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// 获得当前帧的最后一个包的序列号，设置为初始PID，后面还会设置一次Unwrap
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">frame</span><span class="o">-&gt;</span><span class="n">SetId</span><span class="p">(</span><span class="n">frame</span><span class="o">-&gt;</span><span class="n">last_seq_num</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 设置帧的参考帧数，P帧才需要1个参考帧
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">frame</span><span class="o">-&gt;</span><span class="n">num_references</span> <span class="o">=</span>
</span></span><span class="line"><span class="cl">      <span class="n">frame</span><span class="o">-&gt;</span><span class="n">frame_type</span><span class="p">()</span> <span class="o">==</span> <span class="n">VideoFrameType</span><span class="o">::</span><span class="n">kVideoFrameDelta</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 设置参考帧为当前GOP的最新一个帧的最后一个包的序列号
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// 既然该帧是连续的，那么其参考帧自然也就是上个帧
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">frame</span><span class="o">-&gt;</span><span class="n">references</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">rtp_seq_num_unwrapper_</span><span class="p">.</span><span class="n">Unwrap</span><span class="p">(</span><span class="n">last_picture_id_gop</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 如果当前帧比当前GOP的最新一个帧的最后一个包还新，则更新GOP的最新一个帧的最后一个包(first)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// 以及GOP的最新包(second)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">if</span> <span class="p">(</span><span class="n">AheadOf</span><span class="o">&lt;</span><span class="kt">uint16_t</span><span class="o">&gt;</span><span class="p">(</span><span class="n">frame</span><span class="o">-&gt;</span><span class="n">Id</span><span class="p">(),</span> <span class="n">last_picture_id_gop</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">seq_num_it</span><span class="o">-&gt;</span><span class="n">second</span><span class="p">.</span><span class="n">first</span> <span class="o">=</span> <span class="n">frame</span><span class="o">-&gt;</span><span class="n">Id</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="n">seq_num_it</span><span class="o">-&gt;</span><span class="n">second</span><span class="p">.</span><span class="n">second</span> <span class="o">=</span> <span class="n">frame</span><span class="o">-&gt;</span><span class="n">Id</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 更新填充包状态
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">UpdateLastPictureIdWithPadding</span><span class="p">(</span><span class="n">frame</span><span class="o">-&gt;</span><span class="n">Id</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">  <span class="n">frame</span><span class="o">-&gt;</span><span class="n">SetSpatialIndex</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 设置当前帧的PID为Unwrap形式
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">frame</span><span class="o">-&gt;</span><span class="n">SetId</span><span class="p">(</span><span class="n">rtp_seq_num_unwrapper_</span><span class="p">.</span><span class="n">Unwrap</span><span class="p">(</span><span class="n">frame</span><span class="o">-&gt;</span><span class="n">Id</span><span class="p">()));</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="n">kHandOff</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">RtpSeqNumOnlyRefFinder</span><span class="o">::</span><span class="n">RetryStashedFrames</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="n">RtpFrameReferenceFinder</span><span class="o">::</span><span class="n">ReturnVector</span><span class="o">&amp;</span> <span class="n">res</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kt">bool</span> <span class="n">complete_frame</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">do</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">complete_frame</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="n">frame_it</span> <span class="o">=</span> <span class="n">stashed_frames_</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">         <span class="n">frame_it</span> <span class="o">!=</span> <span class="n">stashed_frames_</span><span class="p">.</span><span class="n">end</span><span class="p">();)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">FrameDecision</span> <span class="n">decision</span> <span class="o">=</span> <span class="n">ManageFrameInternal</span><span class="p">(</span><span class="n">frame_it</span><span class="o">-&gt;</span><span class="n">get</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      <span class="k">switch</span> <span class="p">(</span><span class="n">decision</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">case</span> <span class="nl">kStash</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">          <span class="o">++</span><span class="n">frame_it</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">          <span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">case</span> <span class="nl">kHandOff</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">          <span class="n">complete_frame</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">          <span class="n">res</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="o">*</span><span class="n">frame_it</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">          <span class="na">[[fallthrough]]</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">case</span> <span class="nl">kDrop</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">          <span class="n">frame_it</span> <span class="o">=</span> <span class="n">stashed_frames_</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">frame_it</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">complete_frame</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>这里的<code>ManageFrameInternal</code>的核心逻辑实际上就是前面所说的，处理 GOP 内帧的连续性以及设置参考帧。至此就完成了 GOP 内的帧排序。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">RtpVideoStreamReceiver2</span><span class="o">::</span><span class="n">OnCompleteFrames</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="n">RtpFrameReferenceFinder</span><span class="o">::</span><span class="n">ReturnVector</span> <span class="n">frames</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">RTC_DCHECK_RUN_ON</span><span class="p">(</span><span class="o">&amp;</span><span class="n">packet_sequence_checker_</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="k">for</span> <span class="p">(</span><span class="k">auto</span><span class="o">&amp;</span> <span class="nl">frame</span> <span class="p">:</span> <span class="n">frames</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">last_seq_num_for_pic_id_</span><span class="p">[</span><span class="n">frame</span><span class="o">-&gt;</span><span class="n">Id</span><span class="p">()]</span> <span class="o">=</span> <span class="n">frame</span><span class="o">-&gt;</span><span class="n">last_seq_num</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">last_completed_picture_id_</span> <span class="o">=</span>
</span></span><span class="line"><span class="cl">        <span class="n">std</span><span class="o">::</span><span class="n">max</span><span class="p">(</span><span class="n">last_completed_picture_id_</span><span class="p">,</span> <span class="n">frame</span><span class="o">-&gt;</span><span class="n">Id</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">    <span class="n">complete_frame_callback_</span><span class="o">-&gt;</span><span class="n">OnCompleteFrame</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">frame</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>而<code>OnCompleteFrames</code>则接受<code>MangeFrame</code>的返回值作为参数，遍历 GOP 中已经排好序的 Frame 调用<code>complete_frame_callback_</code>的<code>OnCompleteFrame</code>函数。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">VideoReceiveStream2</span><span class="o">::</span><span class="n">OnCompleteFrame</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">EncodedFrame</span><span class="o">&gt;</span> <span class="n">frame</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">RTC_DCHECK_RUN_ON</span><span class="p">(</span><span class="o">&amp;</span><span class="n">worker_sequence_checker_</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="n">absl</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="n">VideoPlayoutDelay</span><span class="o">&gt;</span> <span class="n">playout_delay</span> <span class="o">=</span>
</span></span><span class="line"><span class="cl">          <span class="n">frame</span><span class="o">-&gt;</span><span class="n">EncodedImage</span><span class="p">().</span><span class="n">PlayoutDelay</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">frame_minimum_playout_delay_</span> <span class="o">=</span> <span class="n">playout_delay</span><span class="o">-&gt;</span><span class="n">min</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="n">frame_maximum_playout_delay_</span> <span class="o">=</span> <span class="n">playout_delay</span><span class="o">-&gt;</span><span class="n">max</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="n">UpdatePlayoutDelays</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">auto</span> <span class="n">last_continuous_pid</span> <span class="o">=</span> <span class="n">buffer_</span><span class="o">-&gt;</span><span class="n">InsertFrame</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">frame</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="n">last_continuous_pid</span><span class="p">.</span><span class="n">has_value</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="c1">// TODO(bugs.webrtc.org/11993): Call on the network thread.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="n">RTC_DCHECK_RUN_ON</span><span class="p">(</span><span class="o">&amp;</span><span class="n">packet_sequence_checker_</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="n">rtp_video_stream_receiver_</span><span class="p">.</span><span class="n">FrameContinuous</span><span class="p">(</span><span class="o">*</span><span class="n">last_continuous_pid</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span></code></pre></div><p>这里先更新<code>playout_delay</code>用于之后 Jitter 的计算，然后将 frame 插入到<code>VideoStreamBufferController</code>中：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">absl</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="kt">int64_t</span><span class="o">&gt;</span> <span class="n">VideoStreamBufferController</span><span class="o">::</span><span class="n">InsertFrame</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">EncodedFrame</span><span class="o">&gt;</span> <span class="n">frame</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">RTC_DCHECK_RUN_ON</span><span class="p">(</span><span class="o">&amp;</span><span class="n">worker_sequence_checker_</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">FrameMetadata</span> <span class="nf">metadata</span><span class="p">(</span><span class="o">*</span><span class="n">frame</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="kt">int</span> <span class="n">complete_units</span> <span class="o">=</span> <span class="n">buffer_</span><span class="o">-&gt;</span><span class="n">GetTotalNumberOfContinuousTemporalUnits</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="n">buffer_</span><span class="o">-&gt;</span><span class="n">InsertFrame</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">frame</span><span class="p">)))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">RTC_DCHECK</span><span class="p">(</span><span class="n">metadata</span><span class="p">.</span><span class="n">receive_time</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Frame receive time must be set!&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">metadata</span><span class="p">.</span><span class="n">delayed_by_retransmission</span> <span class="o">&amp;&amp;</span> <span class="n">metadata</span><span class="p">.</span><span class="n">receive_time</span> <span class="o">&amp;&amp;</span>
</span></span><span class="line"><span class="cl">        <span class="p">(</span><span class="n">field_trials_</span><span class="p">.</span><span class="n">IsDisabled</span><span class="p">(</span><span class="s">&#34;WebRTC-IncomingTimestampOnMarkerBitOnly&#34;</span><span class="p">)</span> <span class="o">||</span>
</span></span><span class="line"><span class="cl">         <span class="n">metadata</span><span class="p">.</span><span class="n">is_last_spatial_layer</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">timing_</span><span class="o">-&gt;</span><span class="n">IncomingTimestamp</span><span class="p">(</span><span class="n">metadata</span><span class="p">.</span><span class="n">rtp_timestamp</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                                 <span class="o">*</span><span class="n">metadata</span><span class="p">.</span><span class="n">receive_time</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">complete_units</span> <span class="o">&lt;</span> <span class="n">buffer_</span><span class="o">-&gt;</span><span class="n">GetTotalNumberOfContinuousTemporalUnits</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">stats_proxy_</span><span class="o">-&gt;</span><span class="n">OnCompleteFrame</span><span class="p">(</span><span class="n">metadata</span><span class="p">.</span><span class="n">is_keyframe</span><span class="p">,</span> <span class="n">metadata</span><span class="p">.</span><span class="n">size</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                                    <span class="n">metadata</span><span class="p">.</span><span class="n">contentType</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="n">MaybeScheduleFrameForRelease</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="n">buffer_</span><span class="o">-&gt;</span><span class="n">LastContinuousFrameId</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>这里的核心逻辑就是将 frame 插入到<code>FrameBuffer</code>中：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">bool</span> <span class="n">FrameBuffer</span><span class="o">::</span><span class="n">InsertFrame</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">EncodedFrame</span><span class="o">&gt;</span> <span class="n">frame</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ValidReferences</span><span class="p">(</span><span class="o">*</span><span class="n">frame</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">RTC_DLOG</span><span class="p">(</span><span class="n">LS_WARNING</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Frame &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">frame</span><span class="o">-&gt;</span><span class="n">Id</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">                         <span class="o">&lt;&lt;</span> <span class="s">&#34; has invalid references, dropping frame.&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 根据frame的id判断是否解码过，解码过就不插入直接返回
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">if</span> <span class="p">(</span><span class="n">frame</span><span class="o">-&gt;</span><span class="n">Id</span><span class="p">()</span> <span class="o">&lt;=</span> <span class="n">decoded_frame_history_</span><span class="p">.</span><span class="n">GetLastDecodedFrameId</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">legacy_frame_id_jump_behavior_</span> <span class="o">&amp;&amp;</span> <span class="n">frame</span><span class="o">-&gt;</span><span class="n">is_keyframe</span><span class="p">()</span> <span class="o">&amp;&amp;</span>
</span></span><span class="line"><span class="cl">        <span class="n">AheadOf</span><span class="p">(</span><span class="n">frame</span><span class="o">-&gt;</span><span class="n">RtpTimestamp</span><span class="p">(),</span>
</span></span><span class="line"><span class="cl">                <span class="o">*</span><span class="n">decoded_frame_history_</span><span class="p">.</span><span class="n">GetLastDecodedFrameTimestamp</span><span class="p">()))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">RTC_DLOG</span><span class="p">(</span><span class="n">LS_WARNING</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">          <span class="o">&lt;&lt;</span> <span class="s">&#34;Keyframe &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">frame</span><span class="o">-&gt;</span><span class="n">Id</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">          <span class="o">&lt;&lt;</span> <span class="s">&#34; has newer timestamp but older picture id, clearing buffer.&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="n">Clear</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="c1">// Already decoded past this frame.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 判断填满buffer的frame是不是I帧，是就清空buffer，否则不插入
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">if</span> <span class="p">(</span><span class="n">frames_</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">==</span> <span class="n">max_size_</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">frame</span><span class="o">-&gt;</span><span class="n">is_keyframe</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">RTC_DLOG</span><span class="p">(</span><span class="n">LS_WARNING</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Keyframe &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">frame</span><span class="o">-&gt;</span><span class="n">Id</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">                           <span class="o">&lt;&lt;</span> <span class="s">&#34; inserted into full buffer, clearing buffer.&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="n">Clear</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="c1">// No space for this frame.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 插入当前帧到FrameBuffer中
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">const</span> <span class="kt">int64_t</span> <span class="n">frame_id</span> <span class="o">=</span> <span class="n">frame</span><span class="o">-&gt;</span><span class="n">Id</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="k">auto</span> <span class="n">insert_res</span> <span class="o">=</span> <span class="n">frames_</span><span class="p">.</span><span class="n">emplace</span><span class="p">(</span><span class="n">frame_id</span><span class="p">,</span> <span class="n">FrameInfo</span><span class="p">{</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">frame</span><span class="p">)});</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">insert_res</span><span class="p">.</span><span class="n">second</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// Frame has already been inserted.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="n">frames_</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">==</span> <span class="n">max_size_</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">RTC_DLOG</span><span class="p">(</span><span class="n">LS_WARNING</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Frame &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">frame_id</span>
</span></span><span class="line"><span class="cl">                         <span class="o">&lt;&lt;</span> <span class="s">&#34; inserted, buffer is now full.&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 前向传播当前FrameBuffer中的解码连续性
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">PropagateContinuity</span><span class="p">(</span><span class="n">insert_res</span><span class="p">.</span><span class="n">first</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 更新下一个可解码的时域单元的timestamp
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">FindNextAndLastDecodableTemporalUnit</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>视频帧的<code>FrameBuffer</code>按照可解码的顺序建立完毕，之后就可以根据 Jitter Delay 来交付给解码器解码了。至此，Buffer 的功能分析完毕，下篇学习分析 Jitter Buffer 的核心算法，也就是 Jitter 的计算过程。</p>
</article>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
  </main>
</div>
<script type="application/javascript" src='https://ayamir.github.io/js/toc.js'></script>
<link rel="stylesheet" href='https://ayamir.github.io/css/toc.css' />


<div id="gitalk-container" class="gitalk-container"></div>
<link rel="stylesheet" href='https://ayamir.github.io/css/gitalk.css'>
<script src='https://ayamir.github.io/js/gitalk.min.js'></script>
<script>
  const gitalk = new Gitalk({
    clientID: '1ee3454a8f1f370a7934',
    clientSecret: '737cbeaf81ce60b50fafd2b0d6c7ebfa42826555',
    repo: 'ayamir.github.io',
    owner: 'ayamir',
    admin: ['ayamir'],
    id: eval("location.pathname"), 
    distractionFreeMode: false 
  });
  (function() {
    gitalk.render('gitalk-container');
  })();
</script>


  <div class="footer container-xl width-full p-responsive">
  <div
    class="position-relative d-flex flex-row-reverse flex-lg-row flex-wrap flex-lg-nowrap flex-justify-center flex-lg-justify-between flex-sm-items-center pt-6 pb-2 mt-6 f6 text-gray border-top border-gray-light ">
    <a aria-label="Homepage" title="GitHub" class="footer-octicon d-none d-lg-block mr-lg-4" href="https://ayamir.github.io/">
      <svg height="24" class="octicon octicon-mark-github" viewBox="0 0 16 16" version="1.1" width="24">
        <path fill-rule="evenodd"
          d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.013 8.013 0 0016 8c0-4.42-3.58-8-8-8z">
        </path>
      </svg>
    </a>
    <ul class="list-style-none d-flex flex-wrap col-12 flex-justify-center flex-lg-justify-between mb-2 mb-lg-0">
      
      <li class="mr-3 mr-lg-0">Theme by <a href='https://github.com/MeiK2333/github-style'>github-style</a></li>
      
    </ul>
  </div>
  <div class="d-flex flex-justify-center pb-6">
    <span class="f6 text-gray-light"></span>
  </div>


</div>
</body>

<script type="application/javascript" src="https://ayamir.github.io/js/github-style.js"></script>

<link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.css"
  integrity="sha384-zB1R0rpPzHqg7Kpt0Aljp8JPLqbXI3bhnPWROx27a9N0Ll6ZP/+DiW/UqRcLbRjq" crossorigin="anonymous">
<script defer src="https://fastly.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.js"
  integrity="sha384-y23I5Q6l+B6vatafAwxRu/0oK/79VlbSz7Q9aiSZUvyWYIYsd+qj+o24G5ZU2zJz" crossorigin="anonymous"></script>
<script defer src="https://fastly.jsdelivr.net/npm/katex@0.11.1/dist/contrib/auto-render.min.js"
  integrity="sha384-kWPLUVMOks5AQFrykwIup5lo0m3iMkkHrD0uJ4H5cjeGihAutqP0yW0J6dpFiVkI" crossorigin="anonymous"
  onload="renderMathInElement(document.body);"></script>




</html>